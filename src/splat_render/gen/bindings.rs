// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.10.0
// Changes made to this file will not be saved.
// SourceHash: a13ab93554e774d3628fbeed4b456cb8b17ba67851fec1ee0e1f0ebcb958473c

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    ProjectForward,
    MapGaussianToIntersects,
    GetTileBinEdges,
    Rasterize,
    RasterizeBackwards,
    ProjectBackwards,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::ProjectForward => project_forward::create_pipeline_layout(device),
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_pipeline_layout(device)
            }
            Self::GetTileBinEdges => get_tile_bin_edges::create_pipeline_layout(device),
            Self::Rasterize => rasterize::create_pipeline_layout(device),
            Self::RasterizeBackwards => {
                rasterize_backwards::create_pipeline_layout(device)
            }
            Self::ProjectBackwards => project_backwards::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(
        &self,
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        match self {
            Self::ProjectForward => {
                project_forward::create_shader_module_embed_source(device)
            }
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_shader_module_embed_source(device)
            }
            Self::GetTileBinEdges => {
                get_tile_bin_edges::create_shader_module_embed_source(device)
            }
            Self::Rasterize => rasterize::create_shader_module_embed_source(device),
            Self::RasterizeBackwards => {
                rasterize_backwards::create_shader_module_embed_source(device)
            }
            Self::ProjectBackwards => {
                project_backwards::create_shader_module_embed_source(device)
            }
        }
    }
}
mod _root {
    pub use super::*;
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
    const PROJECT_FORWARD_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(project_forward::Uniforms, viewmat) == 0);
        assert!(std::mem::offset_of!(project_forward::Uniforms, focal) == 64);
        assert!(std::mem::offset_of!(project_forward::Uniforms, pixel_center) == 72);
        assert!(std::mem::offset_of!(project_forward::Uniforms, img_size) == 80);
        assert!(std::mem::offset_of!(project_forward::Uniforms, tile_bounds) == 88);
        assert!(std::mem::offset_of!(project_forward::Uniforms, block_width) == 96);
        assert!(std::mem::offset_of!(project_forward::Uniforms, clip_thresh) == 100);
        assert!(std::mem::size_of:: < project_forward::Uniforms > () == 112);
    };
    const MAP_GAUSSIAN_TO_INTERSECTS_UNIFORMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(map_gaussian_to_intersects::Uniforms, tile_bounds) == 0
        );
        assert!(
            std::mem::offset_of!(map_gaussian_to_intersects::Uniforms, block_width) == 8
        );
        assert!(std::mem::size_of:: < map_gaussian_to_intersects::Uniforms > () == 16);
    };
    const RASTERIZE_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(rasterize::Uniforms, img_size) == 0);
        assert!(std::mem::offset_of!(rasterize::Uniforms, background) == 16);
        assert!(std::mem::size_of:: < rasterize::Uniforms > () == 32);
    };
    const RASTERIZE_BACKWARDS_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(rasterize_backwards::Uniforms, img_size) == 0);
        assert!(std::mem::offset_of!(rasterize_backwards::Uniforms, background) == 16);
        assert!(std::mem::size_of:: < rasterize_backwards::Uniforms > () == 32);
    };
    const PROJECT_BACKWARDS_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(project_backwards::Uniforms, viewmat) == 0);
        assert!(std::mem::offset_of!(project_backwards::Uniforms, focal) == 64);
        assert!(std::mem::offset_of!(project_backwards::Uniforms, img_size) == 72);
        assert!(std::mem::size_of:: < project_backwards::Uniforms > () == 80);
    };
}
pub mod project_forward {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub viewmat: glam::Mat4,
        /// size: 8, offset: 0x40, type: `vec2<f32>`
        pub focal: [f32; 2],
        /// size: 8, offset: 0x48, type: `vec2<f32>`
        pub pixel_center: [f32; 2],
        /// size: 8, offset: 0x50, type: `vec2<u32>`
        pub img_size: [u32; 2],
        /// size: 8, offset: 0x58, type: `vec2<u32>`
        pub tile_bounds: [u32; 2],
        /// size: 4, offset: 0x60, type: `u32`
        pub block_width: u32,
        /// size: 4, offset: 0x64, type: `f32`
        pub clip_thresh: f32,
        pub _pad_clip_thresh: [u8; 0xC - core::mem::size_of::<f32>()],
    }
    impl Uniforms {
        pub const fn new(
            viewmat: glam::Mat4,
            focal: [f32; 2],
            pixel_center: [f32; 2],
            img_size: [u32; 2],
            tile_bounds: [u32; 2],
            block_width: u32,
            clip_thresh: f32,
        ) -> Self {
            Self {
                viewmat,
                focal,
                pixel_center,
                img_size,
                tile_bounds,
                block_width,
                clip_thresh,
                _pad_clip_thresh: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub viewmat: glam::Mat4,
        pub focal: [f32; 2],
        pub pixel_center: [f32; 2],
        pub img_size: [u32; 2],
        pub tile_bounds: [u32; 2],
        pub block_width: u32,
        pub clip_thresh: f32,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                viewmat: self.viewmat,
                focal: self.focal,
                pixel_center: self.pixel_center,
                img_size: self.img_size,
                tile_bounds: self.tile_bounds,
                block_width: self.block_width,
                clip_thresh: self.clip_thresh,
                _pad_clip_thresh: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub means: wgpu::BufferBinding<'a>,
            pub scales: wgpu::BufferBinding<'a>,
            pub quats: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub depths: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub num_tiles_hit: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.depths),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.num_tiles_hit),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("ProjectForward::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("ProjectForward::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [128, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("ProjectForward::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("project_forward.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct Uniforms {
    viewmat: mat4x4<f32>,
    focal: vec2<f32>,
    pixel_center: vec2<f32>,
    img_size: vec2<u32>,
    tile_bounds: vec2<u32>,
    block_width: u32,
    clip_thresh: f32,
}

const COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX: f32 = 0.3f;

@group(0) @binding(0) 
var<storage> means: array<vec4<f32>>;
@group(0) @binding(1) 
var<storage> scales: array<vec4<f32>>;
@group(0) @binding(2) 
var<storage> quats: array<vec4<f32>>;
@group(0) @binding(3) 
var<storage, read_write> xys: array<vec2<f32>>;
@group(0) @binding(4) 
var<storage, read_write> depths: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> radii: array<u32>;
@group(0) @binding(6) 
var<storage, read_write> cov2ds: array<vec4<f32>>;
@group(0) @binding(7) 
var<storage, read_write> num_tiles_hit: array<u32>;
@group(0) @binding(8) 
var<storage> info_array: array<Uniforms>;

fn get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center: vec2<f32>, dims: vec2<f32>, bounds: vec2<u32>) -> vec4<u32> {
    let min = vec2<u32>(clamp(vec2<i32>((center - dims)), vec2(0i), vec2<i32>(bounds)));
    let max = vec2<u32>(clamp(vec2<i32>(((center + dims) + vec2(1f))), vec2(0i), vec2<i32>(bounds)));
    return vec4<u32>(min, max);
}

fn get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(pix_center: vec2<f32>, pix_radius: u32, tile_bounds: vec2<u32>, block_size: u32) -> vec4<u32> {
    let tile_center = (pix_center / vec2(f32(block_size)));
    let tile_radius = (f32(pix_radius) / f32(block_size));
    let _e11 = get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(tile_center, vec2<f32>(tile_radius, tile_radius), tile_bounds);
    return _e11;
}

fn quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat: vec4<f32>) -> mat3x3<f32> {
    let quat_norm = normalize(quat);
    let w = quat_norm.x;
    let x = quat_norm.y;
    let y = quat_norm.z;
    let z = quat_norm.w;
    return mat3x3<f32>(vec3<f32>((1f - (2f * ((y * y) + (z * z)))), (2f * ((x * y) + (w * z))), (2f * ((x * z) - (w * y)))), vec3<f32>((2f * ((x * y) - (w * z))), (1f - (2f * ((x * x) + (z * z)))), (2f * ((y * z) + (w * x)))), vec3<f32>((2f * ((x * z) + (w * y))), (2f * ((y * z) - (w * x))), (1f - (2f * ((x * x) + (y * y))))));
}

fn scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale: vec3<f32>) -> mat3x3<f32> {
    return mat3x3<f32>(vec3<f32>(scale.x, 0f, 0f), vec3<f32>(0f, scale.y, 0f), vec3<f32>(0f, 0f, scale.z));
}

fn project_pix(fxfy: vec2<f32>, p_view: vec3<f32>, pp: vec2<f32>) -> vec2<f32> {
    let p_proj = (p_view.xy / vec2(max(p_view.z, 0.000001f)));
    return ((p_proj * fxfy) + pp);
}

@compute @workgroup_size(128, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let info = info_array[0];
    let num_points = arrayLength((&means));
    if (idx >= num_points) {
        return;
    }
    let viewmat = info.viewmat;
    let focal = info.focal;
    let pixel_center = info.pixel_center;
    let img_size = info.img_size;
    let tile_bounds_1 = info.tile_bounds;
    let block_width = info.block_width;
    let clip_thresh = info.clip_thresh;
    let _e17 = means[idx];
    let p_world = _e17.xyz;
    let W = mat3x3<f32>(viewmat[0].xyz, viewmat[1].xyz, viewmat[2].xyz);
    let p_view_1 = ((W * p_world) + viewmat[3].xyz);
    if (p_view_1.z <= clip_thresh) {
        return;
    }
    let _e34 = scales[idx];
    let scale_1 = _e34.xyz;
    let quat_1 = quats[idx];
    let _e39 = quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat_1);
    let _e40 = scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale_1);
    let M = (_e39 * _e40);
    let V = (M * transpose(M));
    let tan_fov = ((0.5f * vec2<f32>(img_size.xy)) / focal);
    let lims = (1.3f * tan_fov);
    let t = (p_view_1.z * clamp((p_view_1.xy / vec2(p_view_1.z)), -(lims), lims));
    let rz = (1f / p_view_1.z);
    let rz2_ = (rz * rz);
    let J = mat3x3<f32>(vec3<f32>((focal.x * rz), 0f, 0f), vec3<f32>(0f, (focal.y * rz), 0f), vec3<f32>(((-(focal.x) * t.x) * rz2_), ((-(focal.y) * t.y) * rz2_), 0f));
    let T = (J * W);
    let cov = ((T * V) * transpose(T));
    let c00_ = cov[0].x;
    let c11_ = cov[1].y;
    let c01_ = cov[0].y;
    let cov2d = vec3<f32>((c00_ + COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX), c01_, (c11_ + COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX));
    let det = ((cov2d.x * cov2d.z) - (cov2d.y * cov2d.y));
    let b = (0.5f * (cov2d.x + cov2d.z));
    let v1_ = (b + sqrt(max(0.1f, ((b * b) - det))));
    let v2_ = (b - sqrt(max(0.1f, ((b * b) - det))));
    let radius = u32(ceil((3f * sqrt(max(0f, max(v1_, v2_))))));
    if (radius == 0u) {
        return;
    }
    let _e135 = project_pix(focal, p_view_1, pixel_center);
    let _e136 = get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(_e135, radius, tile_bounds_1, block_width);
    let tile_area = ((_e136.z - _e136.x) * (_e136.w - _e136.y));
    num_tiles_hit[idx] = tile_area;
    depths[idx] = p_view_1.z;
    radii[idx] = radius;
    xys[idx] = _e135;
    cov2ds[idx] = vec4<f32>(cov2d, 1f);
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for project_forward::Uniforms {}
    unsafe impl bytemuck::Pod for project_forward::Uniforms {}
    unsafe impl bytemuck::Zeroable for map_gaussian_to_intersects::Uniforms {}
    unsafe impl bytemuck::Pod for map_gaussian_to_intersects::Uniforms {}
    unsafe impl bytemuck::Zeroable for rasterize::Uniforms {}
    unsafe impl bytemuck::Pod for rasterize::Uniforms {}
    unsafe impl bytemuck::Zeroable for rasterize_backwards::Uniforms {}
    unsafe impl bytemuck::Pod for rasterize_backwards::Uniforms {}
    unsafe impl bytemuck::Zeroable for project_backwards::Uniforms {}
    unsafe impl bytemuck::Pod for project_backwards::Uniforms {}
}
pub mod helpers {
    use super::{_root, _root::*};
    pub const COV_BLUR: f32 = 0.3f32;
}
pub mod map_gaussian_to_intersects {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub tile_bounds: [u32; 2],
        /// size: 4, offset: 0x8, type: `u32`
        pub block_width: u32,
        pub _pad_block_width: [u8; 0x8 - core::mem::size_of::<u32>()],
    }
    impl Uniforms {
        pub const fn new(tile_bounds: [u32; 2], block_width: u32) -> Self {
            Self {
                tile_bounds,
                block_width,
                _pad_block_width: [0; 0x8 - core::mem::size_of::<u32>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub tile_bounds: [u32; 2],
        pub block_width: u32,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                tile_bounds: self.tile_bounds,
                block_width: self.block_width,
                _pad_block_width: [0; 0x8 - core::mem::size_of::<u32>()],
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub xys: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cum_tiles_hit: wgpu::BufferBinding<'a>,
            pub isect_ids: wgpu::BufferBinding<'a>,
            pub gaussian_ids: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.cum_tiles_hit),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("MapGaussianToIntersects::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("MapGaussianToIntersects::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [128, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("MapGaussianToIntersects::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("map_gaussian_to_intersects.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct Uniforms {
    tile_bounds: vec2<u32>,
    block_width: u32,
}

@group(0) @binding(0) 
var<storage> xys: array<vec2<f32>>;
@group(0) @binding(1) 
var<storage> radii: array<u32>;
@group(0) @binding(2) 
var<storage> cum_tiles_hit: array<u32>;
@group(0) @binding(3) 
var<storage, read_write> isect_ids: array<u32>;
@group(0) @binding(4) 
var<storage, read_write> gaussian_ids: array<u32>;
@group(0) @binding(5) 
var<storage> info_array: array<Uniforms>;

fn get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center: vec2<f32>, dims: vec2<f32>, bounds: vec2<u32>) -> vec4<u32> {
    let min = vec2<u32>(clamp(vec2<i32>((center - dims)), vec2(0i), vec2<i32>(bounds)));
    let max = vec2<u32>(clamp(vec2<i32>(((center + dims) + vec2(1f))), vec2(0i), vec2<i32>(bounds)));
    return vec4<u32>(min, max);
}

fn get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(pix_center: vec2<f32>, pix_radius: u32, tile_bounds: vec2<u32>, block_size: u32) -> vec4<u32> {
    let tile_center = (pix_center / vec2(f32(block_size)));
    let tile_radius = (f32(pix_radius) / f32(block_size));
    let _e11 = get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(tile_center, vec2<f32>(tile_radius, tile_radius), tile_bounds);
    return _e11;
}

@compute @workgroup_size(128, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var cur_idx: u32 = 0u;
    var ty: u32;
    var tx: u32;

    let idx = global_id.x;
    if (idx >= arrayLength((&radii))) {
        return;
    }
    let radius = radii[idx];
    if (radius == 0u) {
        return;
    }
    let info = info_array[0];
    let tile_bounds_1 = info.tile_bounds;
    let block_width = info.block_width;
    let center_1 = xys[idx];
    let _e19 = get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center_1, radius, tile_bounds_1, block_width);
    let tile_min = _e19.xy;
    let tile_max = _e19.zw;
    if (idx > 0u) {
        let _e28 = cum_tiles_hit[(idx - 1u)];
        cur_idx = _e28;
    }
    ty = tile_min.y;
    loop {
        let _e32 = ty;
        if (_e32 < tile_max.y) {
        } else {
            break;
        }
        {
            tx = tile_min.x;
            loop {
                let _e37 = tx;
                if (_e37 < tile_max.x) {
                } else {
                    break;
                }
                {
                    let _e40 = tx;
                    let _e41 = ty;
                    let tile_id = (_e40 + (_e41 * tile_bounds_1.x));
                    let _e46 = cur_idx;
                    isect_ids[_e46] = tile_id;
                    let _e49 = cur_idx;
                    gaussian_ids[_e49] = idx;
                    let _e52 = cur_idx;
                    cur_idx = (_e52 + 1u);
                }
                continuing {
                    let _e55 = tx;
                    tx = (_e55 + 1u);
                }
            }
        }
        continuing {
            let _e58 = ty;
            ty = (_e58 + 1u);
        }
    }
    return;
}
"#;
}
pub mod get_tile_bin_edges {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub isect_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("GetTileBinEdges::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("GetTileBinEdges::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [128, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("GetTileBinEdges::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("get_tile_bin_edges.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
@group(0) @binding(0) 
var<storage> isect_ids_sorted: array<u32>;
@group(0) @binding(1) 
var<storage, read_write> tile_bins: array<vec2<u32>>;

@compute @workgroup_size(128, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_intersects = arrayLength((&isect_ids_sorted));
    if (idx >= num_intersects) {
        return;
    }
    let cur_tile_idx = isect_ids_sorted[idx];
    if (idx == (num_intersects - 1u)) {
        tile_bins[cur_tile_idx].y = num_intersects;
    }
    if (idx == 0u) {
        tile_bins[cur_tile_idx].x = 0u;
        return;
    } else {
        let prev_tile_idx = isect_ids_sorted[(idx - 1u)];
        if (prev_tile_idx != cur_tile_idx) {
            tile_bins[prev_tile_idx].y = idx;
            tile_bins[cur_tile_idx].x = idx;
            return;
        } else {
            return;
        }
    }
}
"#;
}
pub mod rasterize {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub img_size: [u32; 2],
        pub _pad_img_size: [u8; 0x10 - core::mem::size_of::<[u32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub background: glam::Vec3A,
    }
    impl Uniforms {
        pub const fn new(img_size: [u32; 2], background: glam::Vec3A) -> Self {
            Self {
                img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub img_size: [u32; 2],
        pub background: glam::Vec3A,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                img_size: self.img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background: self.background,
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub const BLOCK_WIDTH: u32 = 16u32;
    pub const BLOCK_SIZE: u32 = 256u32;
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub gaussian_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub colors: wgpu::BufferBinding<'a>,
            pub opacities: wgpu::BufferBinding<'a>,
            pub out_img: wgpu::BufferBinding<'a>,
            pub final_index: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.opacities),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.out_img),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.final_index),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("Rasterize::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("Rasterize::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Rasterize::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rasterize.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct Uniforms {
    img_size: vec2<u32>,
    background: vec3<f32>,
}

const BLOCK_WIDTH: u32 = 16u;
const BLOCK_SIZE: u32 = 256u;

@group(0) @binding(0) 
var<storage> gaussian_ids_sorted: array<u32>;
@group(0) @binding(1) 
var<storage> tile_bins: array<vec2<u32>>;
@group(0) @binding(2) 
var<storage> xys: array<vec2<f32>>;
@group(0) @binding(3) 
var<storage> cov2ds: array<vec4<f32>>;
@group(0) @binding(4) 
var<storage> colors: array<vec4<f32>>;
@group(0) @binding(5) 
var<storage> opacities: array<f32>;
@group(0) @binding(6) 
var<storage, read_write> out_img: array<vec4<f32>>;
@group(0) @binding(7) 
var<storage, read_write> final_index: array<u32>;
@group(0) @binding(8) 
var<storage> info_array: array<Uniforms>;
var<workgroup> id_batch: array<u32, 256>;
var<workgroup> xy_batch: array<vec2<f32>, 256>;
var<workgroup> opacity_batch: array<f32, 256>;
var<workgroup> colors_batch: array<vec4<f32>, 256>;
var<workgroup> cov2d_batch: array<vec4<f32>, 256>;

fn cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d: vec3<f32>) -> vec3<f32> {
    let det = ((cov2d.x * cov2d.z) - (cov2d.y * cov2d.y));
    return (vec3<f32>(cov2d.z, -(cov2d.y), cov2d.x) / vec3(det));
}

fn cov_compensationX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_1: vec3<f32>) -> f32 {
    let cov_orig = (cov2d_1 - vec3<f32>(0.3f, 0f, 0.3f));
    let det_orig = ((cov_orig.x * cov_orig.z) - (cov_orig.y * cov_orig.y));
    let det_1 = ((cov2d_1.x * cov2d_1.z) - (cov2d_1.y * cov2d_1.y));
    return sqrt(max(0f, (det_orig / det_1)));
}

@compute @workgroup_size(16, 16, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    var done: bool = false;
    var T: f32 = 1f;
    var pix_out: vec3<f32> = vec3(0f);
    var final_idx: u32;
    var b: u32 = 0u;
    var t: u32;

    let info = info_array[0];
    let background = info.background;
    let img_size = info.img_size;
    let tiles_xx = (((img_size.x + BLOCK_WIDTH) - 1u) / BLOCK_WIDTH);
    let tile_id = (workgroup_id.x + (workgroup_id.y * tiles_xx));
    let pix_id = (global_id.x + (global_id.y * img_size.x));
    let pixel_coord = vec2<f32>(global_id.xy);
    let inside = ((global_id.x < img_size.x) && (global_id.y < img_size.y));
    if !(inside) {
        done = true;
    }
    let range = tile_bins[tile_id];
    let num_batches = ((((range.y - range.x) + BLOCK_SIZE) - 1u) / BLOCK_SIZE);
    final_idx = range.y;
    loop {
        let _e55 = b;
        if (_e55 < num_batches) {
        } else {
            break;
        }
        {
            workgroupBarrier();
            let _e58 = b;
            let batch_start = (range.x + (_e58 * BLOCK_SIZE));
            let idx = (batch_start + local_idx);
            if (idx < range.y) {
                let g_id = gaussian_ids_sorted[idx];
                id_batch[local_idx] = g_id;
                let _e75 = xys[g_id];
                xy_batch[local_idx] = _e75;
                let _e80 = opacities[g_id];
                opacity_batch[local_idx] = _e80;
                let _e85 = colors[g_id];
                colors_batch[local_idx] = _e85;
                let _e90 = cov2ds[g_id];
                cov2d_batch[local_idx] = _e90;
            }
            workgroupBarrier();
            let remaining = min(BLOCK_SIZE, (range.y - batch_start));
            let _e95 = done;
            if !(_e95) {
                t = 0u;
                loop {
                    let _e99 = t;
                    if (_e99 < remaining) {
                    } else {
                        break;
                    }
                    {
                        let _e102 = t;
                        let _e104 = cov2d_batch[_e102];
                        let cov2d_2 = _e104.xyz;
                        let _e106 = cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_2);
                        let _e107 = cov_compensationX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_2);
                        let _e109 = t;
                        let xy = xy_batch[_e109];
                        let _e113 = t;
                        let opac = opacity_batch[_e113];
                        let delta = (xy - pixel_coord);
                        let sigma = ((0.5f * (((_e106.x * delta.x) * delta.x) + ((_e106.z * delta.y) * delta.y))) + ((_e106.y * delta.x) * delta.y));
                        let alpha = min(0.99f, ((opac * _e107) * exp(-(sigma))));
                        if ((sigma < 0f) || (alpha < 0.003921569f)) {
                            continue;
                        }
                        let _e148 = T;
                        let next_T = (_e148 * (1f - alpha));
                        if (next_T <= 0.0001f) {
                            done = true;
                            break;
                        }
                        let _e155 = T;
                        let vis = (alpha * _e155);
                        let _e158 = t;
                        let _e160 = colors_batch[_e158];
                        let c = _e160.xyz;
                        let _e164 = pix_out;
                        pix_out = (_e164 + (c * vis));
                        T = next_T;
                        let _e166 = t;
                        final_idx = (batch_start + _e166);
                    }
                    continuing {
                        let _e169 = t;
                        t = (_e169 + 1u);
                    }
                }
            }
        }
        continuing {
            let _e172 = b;
            b = (_e172 + 1u);
        }
    }
    if inside {
        let _e176 = final_idx;
        final_index[pix_id] = _e176;
        let _e177 = pix_out;
        let _e178 = T;
        let final_color = (_e177 + (_e178 * background));
        let _e183 = T;
        out_img[pix_id] = vec4<f32>(final_color, _e183);
        return;
    } else {
        return;
    }
}
"#;
}
pub mod rasterize_backwards {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub img_size: [u32; 2],
        pub _pad_img_size: [u8; 0x10 - core::mem::size_of::<[u32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub background: glam::Vec3A,
    }
    impl Uniforms {
        pub const fn new(img_size: [u32; 2], background: glam::Vec3A) -> Self {
            Self {
                img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub img_size: [u32; 2],
        pub background: glam::Vec3A,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                img_size: self.img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background: self.background,
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub const BLOCK_WIDTH: u32 = 16u32;
    pub const BLOCK_SIZE: u32 = 256u32;
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub gaussian_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub colors: wgpu::BufferBinding<'a>,
            pub opacities: wgpu::BufferBinding<'a>,
            pub final_index: wgpu::BufferBinding<'a>,
            pub output: wgpu::BufferBinding<'a>,
            pub v_output: wgpu::BufferBinding<'a>,
            pub v_xy: wgpu::BufferBinding<'a>,
            pub v_conic: wgpu::BufferBinding<'a>,
            pub v_colors: wgpu::BufferBinding<'a>,
            pub v_opacity: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 14] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.opacities),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.final_index),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.output),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.v_output),
                    },
                    wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(self.v_xy),
                    },
                    wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(self.v_conic),
                    },
                    wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(self.v_colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(self.v_opacity),
                    },
                    wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("RasterizeBackwards::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 9,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 10,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 11,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 12,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 13,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("RasterizeBackwards::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("RasterizeBackwards::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rasterize_backwards.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct Uniforms {
    img_size: vec2<u32>,
    background: vec3<f32>,
}

struct _atomic_compare_exchange_resultUint4_ {
    old_value: u32,
    exchanged: bool,
}

const BLOCK_WIDTH: u32 = 16u;
const BLOCK_SIZE: u32 = 256u;

@group(0) @binding(0) 
var<storage> gaussian_ids_sorted: array<u32>;
@group(0) @binding(1) 
var<storage> tile_bins: array<vec2<u32>>;
@group(0) @binding(2) 
var<storage> xys: array<vec2<f32>>;
@group(0) @binding(3) 
var<storage> cov2ds: array<vec4<f32>>;
@group(0) @binding(4) 
var<storage> colors: array<vec4<f32>>;
@group(0) @binding(5) 
var<storage> opacities: array<f32>;
@group(0) @binding(6) 
var<storage> final_index: array<u32>;
@group(0) @binding(7) 
var<storage> output: array<vec4<f32>>;
@group(0) @binding(8) 
var<storage> v_output: array<vec4<f32>>;
@group(0) @binding(9) 
var<storage, read_write> v_xy: array<atomic<u32>>;
@group(0) @binding(10) 
var<storage, read_write> v_conic: array<atomic<u32>>;
@group(0) @binding(11) 
var<storage, read_write> v_colors: array<atomic<u32>>;
@group(0) @binding(12) 
var<storage, read_write> v_opacity: array<atomic<u32>>;
@group(0) @binding(13) 
var<storage> info_array: array<Uniforms>;
var<workgroup> id_batch: array<u32, 256>;
var<workgroup> xy_batch: array<vec2<f32>, 256>;
var<workgroup> opacity_batch: array<f32, 256>;
var<workgroup> color_batch: array<vec4<f32>, 256>;
var<workgroup> cov2d_batch: array<vec4<f32>, 256>;
var<workgroup> v_opacity_local: array<f32, 256>;
var<workgroup> v_conic_local: array<vec3<f32>, 256>;
var<workgroup> v_xy_local: array<vec2<f32>, 256>;
var<workgroup> v_colors_local: array<vec3<f32>, 256>;

fn cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d: vec3<f32>) -> vec3<f32> {
    let det = ((cov2d.x * cov2d.z) - (cov2d.y * cov2d.y));
    return (vec3<f32>(cov2d.z, -(cov2d.y), cov2d.x) / vec3(det));
}

fn bitAddFloat(cur: u32, add: f32) -> u32 {
    return bitcast<u32>((bitcast<f32>(cur) + add));
}

@compute @workgroup_size(16, 16, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    var T: f32;
    var buffer: vec3<f32> = vec3<f32>(0f, 0f, 0f);
    var range: vec2<u32>;
    var num_batches: u32;
    var batch: u32 = 0u;
    var t: u32;
    var sigma: f32;
    var v_alpha: f32;
    var v_colors_sum: vec3<f32>;
    var v_conic_sum: vec3<f32>;
    var v_xy_sum: vec2<f32>;
    var v_opacity_sum: f32;
    var i: u32;

    let info = info_array[0];
    let background = info.background;
    let img_size = info.img_size;
    let tiles_xx = (((img_size.x + BLOCK_WIDTH) - 1u) / BLOCK_WIDTH);
    let tile_id = (workgroup_id.x + (workgroup_id.y * tiles_xx));
    let pix_id = (global_id.x + (global_id.y * img_size.x));
    let pixel_coord = vec2<f32>(global_id.xy);
    let inside = ((global_id.x < img_size.x) && (global_id.y < img_size.y));
    let T_final = output[pix_id].w;
    T = T_final;
    let _e42 = tile_bins[tile_id];
    range = _e42;
    if inside {
        let _e47 = final_index[pix_id];
        range.y = _e47;
    }
    let v_out = v_output[pix_id];
    let _e52 = range.y;
    let _e54 = range.x;
    num_batches = ((((_e52 - _e54) + BLOCK_SIZE) - 1u) / BLOCK_SIZE);
    loop {
        let _e64 = batch;
        let _e65 = num_batches;
        if (_e64 < _e65) {
        } else {
            break;
        }
        {
            let _e68 = range.y;
            let _e71 = batch;
            let gauss_idx_start = ((_e68 - 1u) - (_e71 * BLOCK_SIZE));
            workgroupBarrier();
            let idx = (gauss_idx_start - local_idx);
            let _e78 = range.x;
            if (idx >= _e78) {
                let g_id = gaussian_ids_sorted[idx];
                id_batch[local_idx] = g_id;
                let _e89 = xys[g_id];
                xy_batch[local_idx] = _e89;
                let _e94 = opacities[g_id];
                opacity_batch[local_idx] = _e94;
                let _e99 = colors[g_id];
                color_batch[local_idx] = _e99;
                let _e104 = cov2ds[g_id];
                cov2d_batch[local_idx] = _e104;
            }
            workgroupBarrier();
            let _e108 = range.x;
            let remaining = min(BLOCK_SIZE, ((gauss_idx_start + 1u) - _e108));
            t = 0u;
            loop {
                let _e114 = t;
                if (_e114 < remaining) {
                } else {
                    break;
                }
                {
                    let _e117 = t;
                    let g_id_1 = id_batch[_e117];
                    workgroupBarrier();
                    if inside {
                        let _e121 = t;
                        let _e123 = cov2d_batch[_e121];
                        let _e125 = cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(_e123.xyz);
                        let _e127 = t;
                        let xy = xy_batch[_e127];
                        let _e131 = t;
                        let opac = opacity_batch[_e131];
                        let delta = (xy - pixel_coord);
                        sigma = ((0.5f * (((_e125.x * delta.x) * delta.x) + ((_e125.z * delta.y) * delta.y))) + ((_e125.y * delta.x) * delta.y));
                        let _e156 = sigma;
                        let alpha = min(0.99f, (opac * exp(-(_e156))));
                        let _e161 = sigma;
                        if (_e161 > 0f) {
                            let _e164 = sigma;
                            let vis = exp(-(_e164));
                            let ra = (1f / (1f - alpha));
                            let _e171 = T;
                            T = (_e171 * ra);
                            let _e173 = T;
                            let fac = (alpha * _e173);
                            v_colors_local[local_idx] = (fac * v_out.xyz);
                            v_alpha = 0f;
                            let _e182 = t;
                            let _e184 = color_batch[_e182];
                            let color = _e184.xyz;
                            let _e187 = T;
                            let _e189 = buffer;
                            let _e194 = v_alpha;
                            v_alpha = (_e194 + dot(((color * _e187) - (_e189 * ra)), v_out.xyz));
                            let _e199 = v_alpha;
                            v_alpha = (_e199 + ((T_final * ra) * v_out.w));
                            let _e205 = v_alpha;
                            v_alpha = (_e205 - dot(((T_final * ra) * background), v_out.xyz));
                            let _e208 = buffer;
                            buffer = (_e208 + (color * fac));
                            let _e212 = v_alpha;
                            let v_sigma = ((-(opac) * vis) * _e212);
                            v_conic_local[local_idx] = vec3<f32>((((0.5f * v_sigma) * delta.x) * delta.x), ((v_sigma * delta.x) * delta.y), (((0.5f * v_sigma) * delta.y) * delta.y));
                            v_xy_local[local_idx] = (v_sigma * vec2<f32>(((_e125.x * delta.x) + (_e125.y * delta.y)), ((_e125.y * delta.x) + (_e125.z * delta.y))));
                            let _e253 = v_alpha;
                            v_opacity_local[local_idx] = (vis * _e253);
                        }
                    }
                    workgroupBarrier();
                    if !(inside) {
                        continue;
                    }
                    if (local_idx == 0u) {
                        v_colors_sum = vec3(0f);
                        v_conic_sum = vec3(0f);
                        v_xy_sum = vec2(0f);
                        v_opacity_sum = 0f;
                        i = 0u;
                        loop {
                            let _e271 = i;
                            if (_e271 < BLOCK_SIZE) {
                            } else {
                                break;
                            }
                            {
                                let _e275 = i;
                                let _e277 = v_colors_local[_e275];
                                let _e278 = v_colors_sum;
                                v_colors_sum = (_e278 + _e277);
                                let _e281 = i;
                                let _e283 = v_conic_local[_e281];
                                let _e284 = v_conic_sum;
                                v_conic_sum = (_e284 + _e283);
                                let _e287 = i;
                                let _e289 = v_xy_local[_e287];
                                let _e290 = v_xy_sum;
                                v_xy_sum = (_e290 + _e289);
                                let _e293 = i;
                                let _e295 = v_opacity_local[_e293];
                                let _e296 = v_opacity_sum;
                                v_opacity_sum = (_e296 + _e295);
                            }
                            continuing {
                                let _e299 = i;
                                i = (_e299 + 1u);
                            }
                        }
                        loop {
                            let old = atomicLoad((&v_colors[((g_id_1 * 4u) + 0u)]));
                            let _e315 = v_colors_sum.x;
                            let _e316 = bitAddFloat(old, _e315);
                            let _e317 = atomicCompareExchangeWeak((&v_colors[((g_id_1 * 4u) + 0u)]), old, _e316);
                            if _e317.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_1 = atomicLoad((&v_colors[((g_id_1 * 4u) + 1u)]));
                            let _e333 = v_colors_sum.y;
                            let _e334 = bitAddFloat(old_1, _e333);
                            let _e335 = atomicCompareExchangeWeak((&v_colors[((g_id_1 * 4u) + 1u)]), old_1, _e334);
                            if _e335.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_2 = atomicLoad((&v_colors[((g_id_1 * 4u) + 2u)]));
                            let _e351 = v_colors_sum.z;
                            let _e352 = bitAddFloat(old_2, _e351);
                            let _e353 = atomicCompareExchangeWeak((&v_colors[((g_id_1 * 4u) + 2u)]), old_2, _e352);
                            if _e353.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_3 = atomicLoad((&v_conic[((g_id_1 * 4u) + 0u)]));
                            let _e369 = v_conic_sum.x;
                            let _e370 = bitAddFloat(old_3, _e369);
                            let _e371 = atomicCompareExchangeWeak((&v_conic[((g_id_1 * 4u) + 0u)]), old_3, _e370);
                            if _e371.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_4 = atomicLoad((&v_conic[((g_id_1 * 4u) + 1u)]));
                            let _e387 = v_conic_sum.y;
                            let _e388 = bitAddFloat(old_4, _e387);
                            let _e389 = atomicCompareExchangeWeak((&v_conic[((g_id_1 * 4u) + 1u)]), old_4, _e388);
                            if _e389.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_5 = atomicLoad((&v_conic[((g_id_1 * 4u) + 2u)]));
                            let _e405 = v_conic_sum.z;
                            let _e406 = bitAddFloat(old_5, _e405);
                            let _e407 = atomicCompareExchangeWeak((&v_conic[((g_id_1 * 4u) + 2u)]), old_5, _e406);
                            if _e407.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_6 = atomicLoad((&v_xy[((g_id_1 * 2u) + 0u)]));
                            let _e423 = v_xy_sum.x;
                            let _e424 = bitAddFloat(old_6, _e423);
                            let _e425 = atomicCompareExchangeWeak((&v_xy[((g_id_1 * 2u) + 0u)]), old_6, _e424);
                            if _e425.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_7 = atomicLoad((&v_xy[((g_id_1 * 2u) + 1u)]));
                            let _e441 = v_xy_sum.y;
                            let _e442 = bitAddFloat(old_7, _e441);
                            let _e443 = atomicCompareExchangeWeak((&v_xy[((g_id_1 * 2u) + 1u)]), old_7, _e442);
                            if _e443.exchanged {
                                break;
                            }
                        }
                        loop {
                            let old_8 = atomicLoad((&v_opacity[g_id_1]));
                            let _e450 = v_opacity_sum;
                            let _e451 = bitAddFloat(old_8, _e450);
                            let _e452 = atomicCompareExchangeWeak((&v_opacity[g_id_1]), old_8, _e451);
                            if _e452.exchanged {
                                break;
                            }
                        }
                    }
                }
                continuing {
                    let _e455 = t;
                    t = (_e455 + 1u);
                }
            }
        }
        continuing {
            let _e458 = batch;
            batch = (_e458 + 1u);
        }
    }
    return;
}
"#;
}
pub mod project_backwards {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub viewmat: glam::Mat4,
        /// size: 8, offset: 0x40, type: `vec2<f32>`
        pub focal: [f32; 2],
        /// size: 8, offset: 0x48, type: `vec2<u32>`
        pub img_size: [u32; 2],
    }
    impl Uniforms {
        pub const fn new(
            viewmat: glam::Mat4,
            focal: [f32; 2],
            img_size: [u32; 2],
        ) -> Self {
            Self { viewmat, focal, img_size }
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub means: wgpu::BufferBinding<'a>,
            pub scales: wgpu::BufferBinding<'a>,
            pub quats: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub v_xy: wgpu::BufferBinding<'a>,
            pub v_conic: wgpu::BufferBinding<'a>,
            pub v_opacity: wgpu::BufferBinding<'a>,
            pub v_means: wgpu::BufferBinding<'a>,
            pub v_scales: wgpu::BufferBinding<'a>,
            pub v_quats: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.v_xy),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.v_conic),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.v_opacity),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.v_means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(self.v_scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(self.v_quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("ProjectBackwards::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 9,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 10,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 11,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("ProjectBackwards::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [128, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("ProjectBackwards::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("project_backwards.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct Uniforms {
    viewmat: mat4x4<f32>,
    focal: vec2<f32>,
    img_size: vec2<u32>,
}

const COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX: f32 = 0.3f;

@group(0) @binding(0) 
var<storage> means: array<vec4<f32>>;
@group(0) @binding(1) 
var<storage> scales: array<vec4<f32>>;
@group(0) @binding(2) 
var<storage> quats: array<vec4<f32>>;
@group(0) @binding(3) 
var<storage> radii: array<i32>;
@group(0) @binding(4) 
var<storage> cov2ds: array<vec4<f32>>;
@group(0) @binding(5) 
var<storage> v_xy_1: array<vec2<f32>>;
@group(0) @binding(6) 
var<storage> v_conic_1: array<vec4<f32>>;
@group(0) @binding(7) 
var<storage> v_opacity: array<f32>;
@group(0) @binding(8) 
var<storage, read_write> v_means: array<vec4<f32>>;
@group(0) @binding(9) 
var<storage, read_write> v_scales: array<vec4<f32>>;
@group(0) @binding(10) 
var<storage, read_write> v_quats: array<vec4<f32>>;
@group(0) @binding(11) 
var<storage> info_array: array<Uniforms>;

fn quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat: vec4<f32>) -> mat3x3<f32> {
    let quat_norm = normalize(quat);
    let w = quat_norm.x;
    let x = quat_norm.y;
    let y = quat_norm.z;
    let z = quat_norm.w;
    return mat3x3<f32>(vec3<f32>((1f - (2f * ((y * y) + (z * z)))), (2f * ((x * y) + (w * z))), (2f * ((x * z) - (w * y)))), vec3<f32>((2f * ((x * y) - (w * z))), (1f - (2f * ((x * x) + (z * z)))), (2f * ((y * z) + (w * x)))), vec3<f32>((2f * ((x * z) + (w * y))), (2f * ((y * z) - (w * x))), (1f - (2f * ((x * x) + (y * y))))));
}

fn scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale: vec3<f32>) -> mat3x3<f32> {
    return mat3x3<f32>(vec3<f32>(scale.x, 0f, 0f), vec3<f32>(0f, scale.y, 0f), vec3<f32>(0f, 0f, scale.z));
}

fn cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d: vec3<f32>) -> vec3<f32> {
    let det = ((cov2d.x * cov2d.z) - (cov2d.y * cov2d.y));
    return (vec3<f32>(cov2d.z, -(cov2d.y), cov2d.x) / vec3(det));
}

fn cov_compensationX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_1: vec3<f32>) -> f32 {
    let cov_orig = (cov2d_1 - vec3<f32>(0.3f, 0f, 0.3f));
    let det_orig = ((cov_orig.x * cov_orig.z) - (cov_orig.y * cov_orig.y));
    let det_1 = ((cov2d_1.x * cov2d_1.z) - (cov2d_1.y * cov2d_1.y));
    return sqrt(max(0f, (det_orig / det_1)));
}

fn project_pix_vjp(fxfy: vec2<f32>, p_view: vec3<f32>, v_xy: vec2<f32>) -> vec3<f32> {
    let rw = (1f / (p_view.z + 0.000001f));
    let v_proj = vec2<f32>((fxfy.x * v_xy.x), (fxfy.y * v_xy.y));
    return vec3<f32>((v_proj.x * rw), (v_proj.y * rw), ((-(((v_proj.x * p_view.x) + (v_proj.y * p_view.y))) * rw) * rw));
}

fn quat_to_rotmat_vjp(quat_1: vec4<f32>, v_R: mat3x3<f32>) -> vec4<f32> {
    let quat_norm_1 = normalize(quat_1);
    let w_1 = quat_norm_1.x;
    let x_1 = quat_norm_1.y;
    let y_1 = quat_norm_1.z;
    let z_1 = quat_norm_1.w;
    return vec4<f32>((2f * (((x_1 * (v_R[1].z - v_R[2].y)) + (y_1 * (v_R[2].x - v_R[0].z))) + (z_1 * (v_R[0].y - v_R[1].x)))), (2f * (((((-2f * x_1) * (v_R[1].y + v_R[2].z)) + (y_1 * (v_R[0].y + v_R[1].x))) + (z_1 * (v_R[0].z + v_R[2].x))) + (w_1 * (v_R[1].z - v_R[2].y)))), (2f * ((((x_1 * (v_R[0].y + v_R[1].x)) - ((2f * y_1) * (v_R[0].x + v_R[2].z))) + (z_1 * (v_R[1].z + v_R[2].y))) + (w_1 * (v_R[2].x - v_R[0].z)))), (2f * ((((x_1 * (v_R[0].z + v_R[2].x)) + (y_1 * (v_R[1].z + v_R[2].y))) - ((2f * z_1) * (v_R[0].x + v_R[1].y))) + (w_1 * (v_R[0].y - v_R[1].x)))));
}

fn cov2d_to_conic_vjp(conic: vec3<f32>, v_conic: vec3<f32>) -> vec3<f32> {
    let X = mat2x2<f32>(vec2<f32>(conic.x, conic.y), vec2<f32>(conic.y, conic.z));
    let G = mat2x2<f32>(vec2<f32>(v_conic.x, (v_conic.y / 2f)), vec2<f32>((v_conic.y / 2f), v_conic.z));
    let v_Sigma = ((X * G) * X);
    return -(vec3<f32>(v_Sigma[0].x, (v_Sigma[1].x + v_Sigma[0].y), v_Sigma[1].y));
}

@compute @workgroup_size(128, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    var v_mean: vec3<f32>;
    var v_cov2d: vec3<f32>;

    let idx = global_id.x;
    let num_points = arrayLength((&means));
    let _e7 = radii[idx];
    if ((idx >= num_points) || (_e7 == 0i)) {
        return;
    }
    let info = info_array[0];
    let viewmat = info.viewmat;
    let focal = info.focal;
    let _e18 = means[idx];
    let mean = _e18.xyz;
    let _e22 = scales[idx];
    let scale_1 = _e22.xyz;
    let quat_2 = quats[idx];
    let W = mat3x3<f32>(viewmat[0].xyz, viewmat[1].xyz, viewmat[2].xyz);
    let p_view_1 = ((W * mean) + viewmat[3].xyz);
    let _e41 = v_xy_1[idx];
    let _e42 = project_pix_vjp(focal, p_view_1, _e41);
    v_mean = (transpose(W) * _e42);
    let _e47 = cov2ds[idx];
    let cov2d_2 = _e47.xyz;
    let _e49 = cov_compensationX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_2);
    let _e50 = cov2d_to_conicX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_2);
    let _e53 = v_conic_1[idx];
    let v_conic_2 = _e53.xyz;
    let _e55 = cov2d_to_conic_vjp(_e50, v_conic_2);
    v_cov2d = _e55;
    let v_compensation = v_opacity[idx];
    let inv_det = ((_e50.x * _e50.z) - (_e50.y * _e50.y));
    let one_minus_sqr_comp = (1f - (_e49 * _e49));
    let v_sqr_comp = ((v_compensation * 0.5f) / (_e49 + 0.000001f));
    let _e93 = v_cov2d;
    v_cov2d = (_e93 + vec3<f32>((v_sqr_comp * ((one_minus_sqr_comp * _e50.x) - (COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX * inv_det))), ((2f * v_sqr_comp) * (one_minus_sqr_comp * _e50.y)), (v_sqr_comp * ((one_minus_sqr_comp * _e50.z) - (COV_BLURX_naga_oil_mod_XNBSWY4DFOJZQX * inv_det)))));
    let rz = (1f / p_view_1.z);
    let rz2_ = (rz * rz);
    let J = mat3x3<f32>(vec3<f32>((focal.x * rz), 0f, 0f), vec3<f32>(0f, (focal.y * rz), 0f), vec3<f32>(((-(focal.x) * p_view_1.x) * rz2_), ((-(focal.y) * p_view_1.y) * rz2_), 0f));
    let _e122 = quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat_2);
    let _e123 = scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale_1);
    let M = (_e122 * _e123);
    let V = (M * transpose(M));
    let _e128 = v_cov2d.x;
    let _e130 = v_cov2d.y;
    let _e136 = v_cov2d.y;
    let _e140 = v_cov2d.z;
    let v_cov = mat3x3<f32>(vec3<f32>(_e128, (0.5f * _e130), 0f), vec3<f32>((0.5f * _e136), _e140, 0f), vec3<f32>(0f, 0f, 0f));
    let T = (J * W);
    let Tt = transpose(T);
    let Vt = transpose(V);
    let v_V = ((Tt * v_cov) * T);
    let v_T = (((v_cov * T) * Vt) + ((transpose(v_cov) * T) * V));
    let v_cov3d0_ = v_V[0].x;
    let v_cov3d1_ = (v_V[0].y + v_V[1].x);
    let v_cov3d2_ = (v_V[0].z + v_V[2].x);
    let v_cov3d3_ = v_V[1].y;
    let v_cov3d4_ = (v_V[1].z + v_V[2].y);
    let v_cov3d5_ = v_V[2].z;
    let v_J = (v_T * transpose(W));
    let rz3_ = (rz2_ * rz);
    let v_t = vec3<f32>(((-(focal.x) * rz2_) * v_J[2].x), ((-(focal.y) * rz2_) * v_J[2].y), (((((-(focal.x) * rz2_) * v_J[0].x) + ((((2f * focal.x) * p_view_1.x) * rz3_) * v_J[2].x)) - ((focal.y * rz2_) * v_J[1].y)) + ((((2f * focal.y) * p_view_1.y) * rz3_) * v_J[2].y)));
    let _e235 = v_mean;
    v_mean = (_e235 + vec3<f32>(dot(v_t, W[0]), dot(v_t, W[1]), dot(v_t, W[2])));
    let v_V_symm = mat3x3<f32>(vec3<f32>(v_cov3d0_, (0.5f * v_cov3d1_), (0.5f * v_cov3d2_)), vec3<f32>((0.5f * v_cov3d1_), v_cov3d3_, (0.5f * v_cov3d4_)), vec3<f32>((0.5f * v_cov3d2_), (0.5f * v_cov3d4_), v_cov3d5_));
    let v_M = ((2f * v_V_symm) * M);
    let v_scale = vec3<f32>(dot(_e122[0], v_M[0]), dot(_e122[1], v_M[1]), dot(_e122[2], v_M[2]));
    let v_R_1 = (v_M * _e123);
    let _e267 = quat_to_rotmat_vjp(quat_2, v_R_1);
    v_quats[idx] = _e267;
    v_scales[idx] = vec4<f32>(v_scale, 0f);
    let _e276 = v_mean;
    v_means[idx] = vec4<f32>(_e276, 0f);
    return;
}
"#;
}
