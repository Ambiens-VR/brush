// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.10.0
// Changes made to this file will not be saved.
// SourceHash: 72ef7770691e15479e796596138c247c93a853d0cdd9d9087c9be25730ddbf2e

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    ProjectForward,
    MapGaussianToIntersects,
    GetTileBinEdges,
    Rasterize,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::ProjectForward => project_forward::create_pipeline_layout(device),
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_pipeline_layout(device)
            }
            Self::GetTileBinEdges => get_tile_bin_edges::create_pipeline_layout(device),
            Self::Rasterize => rasterize::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(
        &self,
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        match self {
            Self::ProjectForward => {
                project_forward::create_shader_module_embed_source(device)
            }
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_shader_module_embed_source(device)
            }
            Self::GetTileBinEdges => {
                get_tile_bin_edges::create_shader_module_embed_source(device)
            }
            Self::Rasterize => rasterize::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
    const HELPERS_INFO_BINDING_ASSERTS: () = {
        assert!(std::mem::offset_of!(helpers::InfoBinding, viewmat) == 0);
        assert!(std::mem::offset_of!(helpers::InfoBinding, projmat) == 64);
        assert!(std::mem::offset_of!(helpers::InfoBinding, intrins) == 128);
        assert!(std::mem::offset_of!(helpers::InfoBinding, img_size) == 144);
        assert!(std::mem::offset_of!(helpers::InfoBinding, tile_bounds) == 152);
        assert!(std::mem::offset_of!(helpers::InfoBinding, glob_scale) == 160);
        assert!(std::mem::offset_of!(helpers::InfoBinding, num_points) == 164);
        assert!(std::mem::offset_of!(helpers::InfoBinding, clip_thresh) == 168);
        assert!(std::mem::offset_of!(helpers::InfoBinding, block_width) == 172);
        assert!(std::mem::offset_of!(helpers::InfoBinding, background) == 176);
        assert!(std::mem::size_of:: < helpers::InfoBinding > () == 192);
    };
}
pub mod helpers {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct InfoBinding {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub viewmat: glam::Mat4,
        /// size: 64, offset: 0x40, type: `mat4x4<f32>`
        pub projmat: glam::Mat4,
        /// size: 16, offset: 0x80, type: `vec4<f32>`
        pub intrins: glam::Vec4,
        /// size: 8, offset: 0x90, type: `vec2<u32>`
        pub img_size: [u32; 2],
        /// size: 8, offset: 0x98, type: `vec2<u32>`
        pub tile_bounds: [u32; 2],
        /// size: 4, offset: 0xA0, type: `f32`
        pub glob_scale: f32,
        /// size: 4, offset: 0xA4, type: `u32`
        pub num_points: u32,
        /// size: 4, offset: 0xA8, type: `f32`
        pub clip_thresh: f32,
        /// size: 4, offset: 0xAC, type: `u32`
        pub block_width: u32,
        /// size: 12, offset: 0xB0, type: `vec3<f32>`
        pub background: glam::Vec3A,
    }
    impl InfoBinding {
        pub const fn new(
            viewmat: glam::Mat4,
            projmat: glam::Mat4,
            intrins: glam::Vec4,
            img_size: [u32; 2],
            tile_bounds: [u32; 2],
            glob_scale: f32,
            num_points: u32,
            clip_thresh: f32,
            block_width: u32,
            background: glam::Vec3A,
        ) -> Self {
            Self {
                viewmat,
                projmat,
                intrins,
                img_size,
                tile_bounds,
                glob_scale,
                num_points,
                clip_thresh,
                block_width,
                background,
            }
        }
    }
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for helpers::InfoBinding {}
    unsafe impl bytemuck::Pod for helpers::InfoBinding {}
}
pub mod project_forward {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub means3d: wgpu::BufferBinding<'a>,
            pub scales: wgpu::BufferBinding<'a>,
            pub quats: wgpu::BufferBinding<'a>,
            pub covs3d: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub depths: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub conics: wgpu::BufferBinding<'a>,
            pub compensation: wgpu::BufferBinding<'a>,
            pub num_tiles_hit: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 11] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.means3d),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.covs3d),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.depths),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.conics),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.compensation),
                    },
                    wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(self.num_tiles_hit),
                    },
                    wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("ProjectForward::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 9,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 10,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("ProjectForward::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("ProjectForward::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("project_forward.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX {
    viewmat: mat4x4<f32>,
    projmat: mat4x4<f32>,
    intrins: vec4<f32>,
    img_size: vec2<u32>,
    tile_bounds: vec2<u32>,
    glob_scale: f32,
    num_points: u32,
    clip_thresh: f32,
    block_width: u32,
    background: vec3<f32>,
}

struct ComputeCov2DBoundsX_naga_oil_mod_XNBSWY4DFOJZQX {
    conic: vec3<f32>,
    radius: f32,
    valid: bool,
}

@group(0) @binding(0) 
var<storage> means3d: array<vec3<f32>>;
@group(0) @binding(1) 
var<storage> scales: array<vec3<f32>>;
@group(0) @binding(2) 
var<storage> quats: array<vec4<f32>>;
@group(0) @binding(3) 
var<storage, read_write> covs3d: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> xys: array<vec2<f32>>;
@group(0) @binding(5) 
var<storage, read_write> depths: array<f32>;
@group(0) @binding(6) 
var<storage, read_write> radii: array<i32>;
@group(0) @binding(7) 
var<storage, read_write> conics: array<vec3<f32>>;
@group(0) @binding(8) 
var<storage, read_write> compensation: array<f32>;
@group(0) @binding(9) 
var<storage, read_write> num_tiles_hit: array<i32>;
@group(0) @binding(10) 
var<storage> info_array: array<InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX>;

fn quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat: vec4<f32>) -> mat3x3<f32> {
    let quat_norm = normalize(quat);
    let x_1 = quat_norm.x;
    let y = quat_norm.y;
    let z = quat_norm.z;
    let w = quat_norm.w;
    return mat3x3<f32>(vec3<f32>((1f - (2f * ((y * y) + (z * z)))), (2f * ((x_1 * y) + (w * z))), (2f * ((x_1 * z) - (w * y)))), vec3<f32>((2f * ((x_1 * y) - (w * z))), (1f - (2f * ((x_1 * x_1) + (z * z)))), (2f * ((y * z) + (w * x_1)))), vec3<f32>((2f * ((x_1 * z) + (w * y))), (2f * ((y * z) - (w * x_1))), (1f - (2f * ((x_1 * x_1) + (y * y))))));
}

fn scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale: vec3<f32>, glob_scale: f32) -> mat3x3<f32> {
    return mat3x3<f32>(vec3<f32>((glob_scale * scale.x), 0f, 0f), vec3<f32>(0f, (glob_scale * scale.y), 0f), vec3<f32>(0f, 0f, (glob_scale * scale.z)));
}

fn scale_rot_to_cov3dX_naga_oil_mod_XNBSWY4DFOJZQX(scale_1: vec3<f32>, glob_scale_1: f32, quat_1: vec4<f32>) -> mat3x3<f32> {
    let _e1 = quat_to_rotmatX_naga_oil_mod_XNBSWY4DFOJZQX(quat_1);
    let _e4 = scale_to_matX_naga_oil_mod_XNBSWY4DFOJZQX(scale_1, glob_scale_1);
    let M = (_e1 * _e4);
    return (M * transpose(M));
}

fn ndc2pixX_naga_oil_mod_XNBSWY4DFOJZQX(x: vec2<f32>, W: vec2<f32>, cx: vec2<f32>) -> vec2<f32> {
    return ((((0.5f * W) * x) + cx) - vec2(0.5f));
}

fn project_pixX_naga_oil_mod_XNBSWY4DFOJZQX(transform: mat4x4<f32>, p: vec3<f32>, img_size: vec2<u32>, pp: vec2<f32>) -> vec2<f32> {
    let p_hom = (transform * vec4<f32>(p, 1f));
    let rw = (1f / (p_hom.w + 0.000001f));
    let p_proj = (p_hom.xyz / vec3((p_hom.w + 0.000001f)));
    let _e21 = ndc2pixX_naga_oil_mod_XNBSWY4DFOJZQX(p_proj.xy, vec2<f32>(img_size.xy), pp);
    return _e21;
}

fn get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center: vec2<f32>, dims: vec2<f32>, img_size_1: vec2<u32>) -> vec4<i32> {
    let bb_min_x = min(max(0i, i32((center.x - dims.x))), i32(img_size_1.x));
    let bb_max_x = min(max(0i, i32(((center.x + dims.x) + 1f))), i32(img_size_1.x));
    let bb_min_y = min(max(0i, i32((center.y - dims.y))), i32(img_size_1.y));
    let bb_max_y = min(max(0i, i32(((center.y + dims.y) + 1f))), i32(img_size_1.y));
    return vec4<i32>(bb_min_x, bb_min_y, bb_max_y, bb_max_y);
}

fn get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(pix_center: vec2<f32>, pix_radius: f32, tile_bounds: vec2<u32>, block_size: u32) -> vec4<i32> {
    let tile_center = (pix_center / vec2(f32(block_size)));
    let tile_radius = (vec2<f32>(pix_radius, pix_radius) / vec2(f32(block_size)));
    let _e11 = get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(tile_center, tile_radius, tile_bounds);
    return _e11;
}

fn compute_cov2d_boundsX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d: vec3<f32>) -> ComputeCov2DBoundsX_naga_oil_mod_XNBSWY4DFOJZQX {
    let det = ((cov2d.x * cov2d.z) - (cov2d.y * cov2d.y));
    if (det == 0f) {
        return ComputeCov2DBoundsX_naga_oil_mod_XNBSWY4DFOJZQX(vec3(0f), 0f, false);
    }
    let conic = (vec3<f32>(cov2d.z, -(cov2d.y), cov2d.x) / vec3(det));
    let b = (0.5f * (cov2d.x + cov2d.z));
    let v1_ = (b + sqrt(max(0.1f, ((b * b) - det))));
    let v2_ = (b - sqrt(max(0.1f, ((b * b) - det))));
    let radius = ceil((3f * sqrt(max(v1_, v2_))));
    return ComputeCov2DBoundsX_naga_oil_mod_XNBSWY4DFOJZQX(conic, radius, true);
}

@compute @workgroup_size(16, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    let info = info_array[0];
    let idx = local_id.x;
    let num_points = info.num_points;
    if (idx >= num_points) {
        return;
    }
    let glob_scale_2 = info.glob_scale;
    let viewmat = info.viewmat;
    let projmat = info.projmat;
    let intrins = info.intrins;
    let img_size_2 = info.img_size;
    let tile_bounds_1 = info.tile_bounds;
    let block_width = info.block_width;
    let clip_thresh = info.clip_thresh;
    radii[idx] = 0i;
    num_tiles_hit[idx] = 0i;
    let p_world = means3d[idx];
    let p_view = (viewmat * vec4<f32>(p_world, 1f));
    if (p_view.z <= clip_thresh) {
        return;
    }
    let scale_2 = scales[idx];
    let quat_2 = quats[idx];
    let _e35 = scale_rot_to_cov3dX_naga_oil_mod_XNBSWY4DFOJZQX(scale_2, glob_scale_2, quat_2);
    let covs0_ = _e35[0].x;
    let covs1_ = _e35[0].y;
    let covs2_ = _e35[0].z;
    let covs3_ = _e35[1].y;
    let covs4_ = _e35[1].z;
    let covs5_ = _e35[2].z;
    covs3d[((6u * idx) + 0u)] = covs0_;
    covs3d[((6u * idx) + 1u)] = covs1_;
    covs3d[((6u * idx) + 2u)] = covs2_;
    covs3d[((6u * idx) + 3u)] = covs3_;
    covs3d[((6u * idx) + 4u)] = covs4_;
    covs3d[((6u * idx) + 5u)] = covs5_;
    let fx = intrins.x;
    let fy = intrins.y;
    let cx_1 = intrins.z;
    let cy = intrins.w;
    let tan_fovx = ((0.5f * f32(img_size_2.x)) / fx);
    let tan_fovy = ((0.5f * f32(img_size_2.y)) / fy);
    let W_1 = mat3x3<f32>(viewmat[0].xyz, viewmat[1].xyz, viewmat[2].xyz);
    let lims = (1.3f * vec2<f32>(tan_fovx, tan_fovy));
    let t = (p_world.z * clamp((p_world.xy / vec2(p_world.z)), -(lims), lims));
    let rz = (1f / p_world.z);
    let rz2_ = (rz * rz);
    let J = mat3x3<f32>(vec3<f32>((fx * rz), 0f, 0f), vec3<f32>(0f, (fy * rz), 0f), vec3<f32>(((-(fx) * t.x) * rz2_), ((-(fy) * t.y) * rz2_), 0f));
    let T = (J * W_1);
    let V = mat3x3<f32>(vec3<f32>(covs0_, covs1_, covs2_), vec3<f32>(covs1_, covs3_, covs4_), vec3<f32>(covs2_, covs4_, covs5_));
    let cov = ((T * V) * transpose(T));
    let c00_ = cov[0].x;
    let c11_ = cov[1].y;
    let c01_ = cov[0].y;
    let det_orig = ((c00_ * c11_) - (c01_ * c01_));
    let cov2d_1 = vec3<f32>((c00_ + 0.3f), c01_, (c11_ + 0.3f));
    let det_blur = ((cov2d_1.x * cov2d_1.z) - (cov2d_1.y * cov2d_1.y));
    let comp = sqrt(max(0f, (det_orig / det_blur)));
    let _e172 = compute_cov2d_boundsX_naga_oil_mod_XNBSWY4DFOJZQX(cov2d_1);
    if !(_e172.valid) {
        return;
    }
    conics[idx] = _e172.conic;
    let _e179 = project_pixX_naga_oil_mod_XNBSWY4DFOJZQX(projmat, p_world, img_size_2, vec2<f32>(cx_1, cy));
    let _e181 = get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(_e179, _e172.radius, tile_bounds_1, block_width);
    let tile_min = _e181.xy;
    let tile_max = _e181.zw;
    let tile_area = ((tile_max.x - tile_min.x) * (tile_max.y - tile_min.y));
    if (tile_area <= 0i) {
        return;
    }
    num_tiles_hit[idx] = i32(tile_area);
    depths[idx] = p_view.z;
    radii[idx] = i32(_e172.radius);
    xys[idx] = _e179;
    compensation[idx] = comp;
    return;
}
"#;
}
pub mod map_gaussian_to_intersects {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub xys: wgpu::BufferBinding<'a>,
            pub depths: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cum_tiles_hit: wgpu::BufferBinding<'a>,
            pub isect_ids: wgpu::BufferBinding<'a>,
            pub gaussian_ids: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.depths),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.cum_tiles_hit),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("MapGaussianToIntersects::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("MapGaussianToIntersects::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("MapGaussianToIntersects::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("map_gaussian_to_intersects.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX {
    viewmat: mat4x4<f32>,
    projmat: mat4x4<f32>,
    intrins: vec4<f32>,
    img_size: vec2<u32>,
    tile_bounds: vec2<u32>,
    glob_scale: f32,
    num_points: u32,
    clip_thresh: f32,
    block_width: u32,
    background: vec3<f32>,
}

@group(0) @binding(0) 
var<storage> xys: array<vec2<f32>>;
@group(0) @binding(1) 
var<storage> depths: array<f32>;
@group(0) @binding(2) 
var<storage> radii: array<i32>;
@group(0) @binding(3) 
var<storage> cum_tiles_hit: array<u32>;
@group(0) @binding(4) 
var<storage, read_write> isect_ids: array<u32>;
@group(0) @binding(5) 
var<storage, read_write> gaussian_ids: array<u32>;
@group(0) @binding(6) 
var<storage> info_array: array<InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX>;

fn get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center: vec2<f32>, dims: vec2<f32>, img_size: vec2<u32>) -> vec4<i32> {
    let bb_min_x = min(max(0i, i32((center.x - dims.x))), i32(img_size.x));
    let bb_max_x = min(max(0i, i32(((center.x + dims.x) + 1f))), i32(img_size.x));
    let bb_min_y = min(max(0i, i32((center.y - dims.y))), i32(img_size.y));
    let bb_max_y = min(max(0i, i32(((center.y + dims.y) + 1f))), i32(img_size.y));
    return vec4<i32>(bb_min_x, bb_min_y, bb_max_y, bb_max_y);
}

fn get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(pix_center: vec2<f32>, pix_radius: f32, tile_bounds: vec2<u32>, block_size: u32) -> vec4<i32> {
    let tile_center = (pix_center / vec2(f32(block_size)));
    let tile_radius = (vec2<f32>(pix_radius, pix_radius) / vec2(f32(block_size)));
    let _e11 = get_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(tile_center, tile_radius, tile_bounds);
    return _e11;
}

@compute @workgroup_size(16, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    var cur_idx: u32 = 0u;
    var i: i32;
    var j: i32;

    let info = info_array[0];
    let num_points = info.num_points;
    let tile_bounds_1 = info.tile_bounds;
    let block_width = info.block_width;
    let idx = global_id.x;
    if (idx >= num_points) {
        return;
    }
    let _e12 = radii[idx];
    if (_e12 <= 0i) {
        return;
    }
    let center_1 = xys[idx];
    let _e20 = radii[idx];
    let _e22 = get_tile_bboxX_naga_oil_mod_XNBSWY4DFOJZQX(center_1, f32(_e20), tile_bounds_1, block_width);
    let tile_min = _e22.xy;
    let tile_max = _e22.zw;
    if (idx != 0u) {
        let _e31 = cum_tiles_hit[(idx - 1u)];
        cur_idx = _e31;
    }
    let _e35 = depths[idx];
    let depth_id = bitcast<u32>(_e35);
    i = tile_min.y;
    loop {
        let _e39 = i;
        if (_e39 < tile_max.y) {
        } else {
            break;
        }
        {
            j = tile_min.x;
            loop {
                let _e44 = j;
                if (_e44 < tile_max.x) {
                } else {
                    break;
                }
                {
                    let _e47 = i;
                    let _e51 = j;
                    let tile_id = u32(((_e47 * i32(tile_bounds_1.x)) + _e51));
                    let _e55 = cur_idx;
                    isect_ids[_e55] = ((tile_id << 32u) | depth_id);
                    let _e61 = cur_idx;
                    gaussian_ids[_e61] = idx;
                    let _e64 = cur_idx;
                    cur_idx = (_e64 + 1u);
                }
                continuing {
                    let _e67 = j;
                    j = (_e67 + 1i);
                }
            }
        }
        continuing {
            let _e70 = i;
            i = (_e70 + 1i);
        }
    }
    return;
}
"#;
}
pub mod get_tile_bin_edges {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub isect_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("GetTileBinEdges::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("GetTileBinEdges::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 1, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("GetTileBinEdges::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("get_tile_bin_edges.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX {
    viewmat: mat4x4<f32>,
    projmat: mat4x4<f32>,
    intrins: vec4<f32>,
    img_size: vec2<u32>,
    tile_bounds: vec2<u32>,
    glob_scale: f32,
    num_points: u32,
    clip_thresh: f32,
    block_width: u32,
    background: vec3<f32>,
}

@group(0) @binding(0) 
var<storage> isect_ids_sorted: array<u32>;
@group(0) @binding(1) 
var<storage, read_write> tile_bins: array<vec2<u32>>;
@group(0) @binding(2) 
var<storage> info_array: array<InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX>;

@compute @workgroup_size(16, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    let info = info_array[0];
    let num_intersects = info.num_points;
    let idx = local_id.x;
    if (idx >= num_intersects) {
        return;
    }
    let _e9 = isect_ids_sorted[idx];
    let cur_tile_idx = i32((_e9 >> 32u));
    if ((idx == 0u) || (idx == (num_intersects - 1u))) {
        if (idx == 0u) {
            tile_bins[cur_tile_idx].x = 0u;
        }
        if (idx == (num_intersects - 1u)) {
            tile_bins[cur_tile_idx].y = num_intersects;
        }
    }
    if (idx == 0u) {
        return;
    }
    let _e37 = isect_ids_sorted[(idx - 1u)];
    let prev_tile_idx = i32((_e37 >> 32u));
    if (prev_tile_idx != cur_tile_idx) {
        tile_bins[prev_tile_idx].y = idx;
        tile_bins[cur_tile_idx].x = idx;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod rasterize {
    use super::{_root, _root::*};
    pub const MAX_BLOCK_SIZE: u32 = 256u32;
    pub const TILE_SIZE: u32 = 16u32;
    pub const GROUP_DIM: u32 = 16u32;
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub gaussian_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub conics: wgpu::BufferBinding<'a>,
            pub colors: wgpu::BufferBinding<'a>,
            pub opacities: wgpu::BufferBinding<'a>,
            pub out_img: wgpu::BufferBinding<'a>,
            pub info_array: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 8] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.conics),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.opacities),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.out_img),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.info_array),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("Rasterize::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("Rasterize::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
        pub fn create_main_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Rasterize::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rasterize.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX {
    viewmat: mat4x4<f32>,
    projmat: mat4x4<f32>,
    intrins: vec4<f32>,
    img_size: vec2<u32>,
    tile_bounds: vec2<u32>,
    glob_scale: f32,
    num_points: u32,
    clip_thresh: f32,
    block_width: u32,
    background: vec3<f32>,
}

const MAX_BLOCK_SIZE: u32 = 256u;
const TILE_SIZE: u32 = 16u;
const GROUP_DIM: u32 = 16u;

@group(0) @binding(0) 
var<storage> gaussian_ids_sorted: array<u32>;
@group(0) @binding(1) 
var<storage> tile_bins: array<vec2<u32>>;
@group(0) @binding(2) 
var<storage> xys: array<vec2<f32>>;
@group(0) @binding(3) 
var<storage> conics: array<vec3<f32>>;
@group(0) @binding(4) 
var<storage> colors: array<vec3<f32>>;
@group(0) @binding(5) 
var<storage> opacities: array<f32>;
@group(0) @binding(6) 
var<storage, read_write> out_img: array<vec4<f32>>;
@group(0) @binding(7) 
var<storage> info_array: array<InfoBindingX_naga_oil_mod_XNBSWY4DFOJZQX>;
var<workgroup> id_batch: array<u32, 256>;
var<workgroup> xy_opacity_batch: array<vec3<f32>, 256>;
var<workgroup> conic_batch: array<vec3<f32>, 256>;
var<workgroup> count_done: atomic<u32>;

@compute @workgroup_size(16, 16, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(local_invocation_index) local_idx: u32, @builtin(workgroup_id) workgroup_id: vec3<u32>) {
    var done: bool;
    var T: f32 = 1f;
    var cur_idx: u32 = 0u;
    var pix_out: vec3<f32> = vec3(0f);
    var b: u32 = 0u;
    var t: u32;

    let info = info_array[0];
    let tile_size = vec2<u32>(16u, 16u);
    let tile_bounds = info.tile_bounds;
    let background = info.background;
    let img_size = info.img_size;
    let tile_id = ((workgroup_id.y * tile_bounds.x) + workgroup_id.x);
    let i = ((workgroup_id.y * GROUP_DIM) + local_id.y);
    let j = ((workgroup_id.x * GROUP_DIM) + local_id.x);
    let px = f32(j);
    let py = f32(i);
    let pix_id = ((i * img_size.x) + j);
    let inside = ((i < img_size.y) && (j < img_size.x));
    done = !(inside);
    let range = tile_bins[tile_id];
    let num_batches = ((((range.y - range.x) + 256u) - 1u) / 256u);
    loop {
        let _e54 = b;
        if (_e54 < num_batches) {
        } else {
            break;
        }
        {
            let _e57 = atomicLoad((&count_done));
            if (_e57 >= 256u) {
                break;
            }
            let _e60 = b;
            let batch_start = (range.x + (256u * _e60));
            let idx = (batch_start + local_idx);
            if (idx < range.y) {
                let g_id = gaussian_ids_sorted[idx];
                id_batch[local_idx] = g_id;
                let _e76 = xys[g_id];
                let _e79 = opacities[g_id];
                xy_opacity_batch[local_idx] = vec3<f32>(_e76, _e79);
                let _e85 = conics[g_id];
                conic_batch[local_idx] = _e85;
            }
            workgroupBarrier();
            let batch_size = min(256u, (range.y - batch_start));
            t = 0u;
            loop {
                let _e91 = t;
                let _e93 = done;
                if ((_e91 < batch_size) && !(_e93)) {
                } else {
                    break;
                }
                {
                    let _e97 = t;
                    let conic = conic_batch[_e97];
                    let _e101 = t;
                    let xy_opac = xy_opacity_batch[_e101];
                    let opac = xy_opac.z;
                    let delta = (xy_opac.xy - vec2<f32>(px, py));
                    let sigma = ((0.5f * (((conic.x * delta.x) * delta.x) + ((conic.z * delta.y) * delta.y))) + ((conic.y * delta.x) * delta.y));
                    let alpha = min(0.999f, (opac * exp(-(sigma))));
                    if ((sigma < 0f) || (alpha < 0.003921569f)) {
                        continue;
                    }
                    let _e138 = T;
                    let next_T = (_e138 * (1f - alpha));
                    if (next_T <= 0.0001f) {
                        let _e146 = atomicAdd((&count_done), 1u);
                        done = true;
                        break;
                    }
                    let _e149 = t;
                    let g = id_batch[_e149];
                    let _e152 = T;
                    let vis = (alpha * _e152);
                    let c = colors[g];
                    let _e159 = pix_out;
                    pix_out = (_e159 + (c * vis));
                    T = next_T;
                    let _e161 = t;
                    cur_idx = (batch_start + _e161);
                }
                continuing {
                    let _e165 = t;
                    t = (_e165 + 1u);
                }
            }
        }
        continuing {
            let _e168 = b;
            b = (_e168 + 1u);
        }
    }
    if inside {
        let _e172 = pix_out;
        let _e173 = T;
        let _e175 = T;
        out_img[pix_id] = (vec4<f32>(_e172, _e173) + vec4<f32>((_e175 * background), 0f));
        return;
    } else {
        return;
    }
}
"#;
}
