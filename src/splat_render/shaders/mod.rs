// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.10.0
// Changes made to this file will not be saved.
// SourceHash: eb850f90e737aba66ab587076cb9e8d6a875756d664db32fe5f291615494c3ca

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    ProjectForward,
    MapGaussianToIntersects,
    GetTileBinEdges,
    Rasterize,
    RasterizeBackwards,
    ProjectBackwards,
    PrefixSumScan,
    PrefixSumScanSums,
    PrefixSumAddScannedSums,
    SortCount,
    SortReduce,
    SortScanAdd,
    SortScan,
    SortScatter,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::ProjectForward => project_forward::create_pipeline_layout(device),
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_pipeline_layout(device)
            }
            Self::GetTileBinEdges => get_tile_bin_edges::create_pipeline_layout(device),
            Self::Rasterize => rasterize::create_pipeline_layout(device),
            Self::RasterizeBackwards => {
                rasterize_backwards::create_pipeline_layout(device)
            }
            Self::ProjectBackwards => project_backwards::create_pipeline_layout(device),
            Self::PrefixSumScan => prefix_sum_scan::create_pipeline_layout(device),
            Self::PrefixSumScanSums => {
                prefix_sum_scan_sums::create_pipeline_layout(device)
            }
            Self::PrefixSumAddScannedSums => {
                prefix_sum_add_scanned_sums::create_pipeline_layout(device)
            }
            Self::SortCount => sort_count::create_pipeline_layout(device),
            Self::SortReduce => sort_reduce::create_pipeline_layout(device),
            Self::SortScanAdd => sort_scan_add::create_pipeline_layout(device),
            Self::SortScan => sort_scan::create_pipeline_layout(device),
            Self::SortScatter => sort_scatter::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embedded(
        &self,
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        match self {
            Self::ProjectForward => {
                project_forward::create_shader_module_embedded(device, shader_defs)
            }
            Self::MapGaussianToIntersects => {
                map_gaussian_to_intersects::create_shader_module_embedded(
                    device,
                    shader_defs,
                )
            }
            Self::GetTileBinEdges => {
                get_tile_bin_edges::create_shader_module_embedded(device, shader_defs)
            }
            Self::Rasterize => {
                rasterize::create_shader_module_embedded(device, shader_defs)
            }
            Self::RasterizeBackwards => {
                rasterize_backwards::create_shader_module_embedded(device, shader_defs)
            }
            Self::ProjectBackwards => {
                project_backwards::create_shader_module_embedded(device, shader_defs)
            }
            Self::PrefixSumScan => {
                prefix_sum_scan::create_shader_module_embedded(device, shader_defs)
            }
            Self::PrefixSumScanSums => {
                prefix_sum_scan_sums::create_shader_module_embedded(device, shader_defs)
            }
            Self::PrefixSumAddScannedSums => {
                prefix_sum_add_scanned_sums::create_shader_module_embedded(
                    device,
                    shader_defs,
                )
            }
            Self::SortCount => {
                sort_count::create_shader_module_embedded(device, shader_defs)
            }
            Self::SortReduce => {
                sort_reduce::create_shader_module_embedded(device, shader_defs)
            }
            Self::SortScanAdd => {
                sort_scan_add::create_shader_module_embedded(device, shader_defs)
            }
            Self::SortScan => {
                sort_scan::create_shader_module_embedded(device, shader_defs)
            }
            Self::SortScatter => {
                sort_scatter::create_shader_module_embedded(device, shader_defs)
            }
        }
    }
}
mod _root {
    pub use super::*;
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
    const PROJECT_FORWARD_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(project_forward::Uniforms, viewmat) == 0);
        assert!(std::mem::offset_of!(project_forward::Uniforms, focal) == 64);
        assert!(std::mem::offset_of!(project_forward::Uniforms, pixel_center) == 72);
        assert!(std::mem::offset_of!(project_forward::Uniforms, img_size) == 80);
        assert!(std::mem::offset_of!(project_forward::Uniforms, tile_bounds) == 88);
        assert!(std::mem::offset_of!(project_forward::Uniforms, block_width) == 96);
        assert!(std::mem::offset_of!(project_forward::Uniforms, clip_thresh) == 100);
        assert!(std::mem::size_of:: < project_forward::Uniforms > () == 112);
    };
    const MAP_GAUSSIAN_TO_INTERSECTS_UNIFORMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(map_gaussian_to_intersects::Uniforms, tile_bounds) == 0
        );
        assert!(std::mem::size_of:: < map_gaussian_to_intersects::Uniforms > () == 8);
    };
    const RASTERIZE_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(rasterize::Uniforms, img_size) == 0);
        assert!(std::mem::offset_of!(rasterize::Uniforms, background) == 16);
        assert!(std::mem::size_of:: < rasterize::Uniforms > () == 32);
    };
    const RASTERIZE_BACKWARDS_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(rasterize_backwards::Uniforms, img_size) == 0);
        assert!(std::mem::offset_of!(rasterize_backwards::Uniforms, background) == 16);
        assert!(std::mem::size_of:: < rasterize_backwards::Uniforms > () == 32);
    };
    const PROJECT_BACKWARDS_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(project_backwards::Uniforms, viewmat) == 0);
        assert!(std::mem::offset_of!(project_backwards::Uniforms, focal) == 64);
        assert!(std::mem::offset_of!(project_backwards::Uniforms, img_size) == 72);
        assert!(std::mem::size_of:: < project_backwards::Uniforms > () == 80);
    };
    const SORTING_CONFIG_ASSERTS: () = {
        assert!(std::mem::offset_of!(sorting::Config, num_keys) == 0);
        assert!(std::mem::offset_of!(sorting::Config, num_blocks_per_wg) == 4);
        assert!(std::mem::offset_of!(sorting::Config, num_wgs) == 8);
        assert!(
            std::mem::offset_of!(sorting::Config, num_wgs_with_additional_blocks) == 12
        );
        assert!(std::mem::offset_of!(sorting::Config, num_reduce_wg_per_bin) == 16);
        assert!(std::mem::offset_of!(sorting::Config, num_scan_values) == 20);
        assert!(std::mem::offset_of!(sorting::Config, shift) == 24);
        assert!(std::mem::size_of:: < sorting::Config > () == 28);
    };
}
pub mod project_forward {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub viewmat: glam::Mat4,
        /// size: 8, offset: 0x40, type: `vec2<f32>`
        pub focal: [f32; 2],
        /// size: 8, offset: 0x48, type: `vec2<f32>`
        pub pixel_center: [f32; 2],
        /// size: 8, offset: 0x50, type: `vec2<u32>`
        pub img_size: [u32; 2],
        /// size: 8, offset: 0x58, type: `vec2<u32>`
        pub tile_bounds: [u32; 2],
        /// size: 4, offset: 0x60, type: `u32`
        pub block_width: u32,
        /// size: 4, offset: 0x64, type: `f32`
        pub clip_thresh: f32,
        pub _pad_clip_thresh: [u8; 0xC - core::mem::size_of::<f32>()],
    }
    impl Uniforms {
        pub const fn new(
            viewmat: glam::Mat4,
            focal: [f32; 2],
            pixel_center: [f32; 2],
            img_size: [u32; 2],
            tile_bounds: [u32; 2],
            block_width: u32,
            clip_thresh: f32,
        ) -> Self {
            Self {
                viewmat,
                focal,
                pixel_center,
                img_size,
                tile_bounds,
                block_width,
                clip_thresh,
                _pad_clip_thresh: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub viewmat: glam::Mat4,
        pub focal: [f32; 2],
        pub pixel_center: [f32; 2],
        pub img_size: [u32; 2],
        pub tile_bounds: [u32; 2],
        pub block_width: u32,
        pub clip_thresh: f32,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                viewmat: self.viewmat,
                focal: self.focal,
                pixel_center: self.pixel_center,
                img_size: self.img_size,
                tile_bounds: self.tile_bounds,
                block_width: self.block_width,
                clip_thresh: self.clip_thresh,
                _pad_clip_thresh: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
            pub means: wgpu::BufferBinding<'a>,
            pub scales: wgpu::BufferBinding<'a>,
            pub quats: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub depths: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub num_tiles_hit: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.uniforms),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.depths),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.num_tiles_hit),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("ProjectForward::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("ProjectForward::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("ProjectForward::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("project_forward.wgsl"),
                file_path: "project_forward.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("project_forward.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for project_forward::Uniforms {}
    unsafe impl bytemuck::Pod for project_forward::Uniforms {}
    unsafe impl bytemuck::Zeroable for map_gaussian_to_intersects::Uniforms {}
    unsafe impl bytemuck::Pod for map_gaussian_to_intersects::Uniforms {}
    unsafe impl bytemuck::Zeroable for rasterize::Uniforms {}
    unsafe impl bytemuck::Pod for rasterize::Uniforms {}
    unsafe impl bytemuck::Zeroable for rasterize_backwards::Uniforms {}
    unsafe impl bytemuck::Pod for rasterize_backwards::Uniforms {}
    unsafe impl bytemuck::Zeroable for project_backwards::Uniforms {}
    unsafe impl bytemuck::Pod for project_backwards::Uniforms {}
    unsafe impl bytemuck::Zeroable for sorting::Config {}
    unsafe impl bytemuck::Pod for sorting::Config {}
}
pub mod helpers {
    use super::{_root, _root::*};
    pub const SPLATS_PER_GROUP: u32 = 256u32;
    pub const COV_BLUR: f32 = 0.3f32;
    pub const TILE_WIDTH: u32 = 26u32;
    pub const TILE_SIZE: u32 = 676u32;
}
pub mod map_gaussian_to_intersects {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub tile_bounds: [u32; 2],
    }
    impl Uniforms {
        pub const fn new(tile_bounds: [u32; 2]) -> Self {
            Self { tile_bounds }
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cum_tiles_hit: wgpu::BufferBinding<'a>,
            pub depths: wgpu::BufferBinding<'a>,
            pub isect_ids: wgpu::BufferBinding<'a>,
            pub gaussian_ids: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.uniforms),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.cum_tiles_hit),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.depths),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("MapGaussianToIntersects::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("MapGaussianToIntersects::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("MapGaussianToIntersects::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("map_gaussian_to_intersects.wgsl"),
                file_path: "map_gaussian_to_intersects.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("map_gaussian_to_intersects.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod get_tile_bin_edges {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub isect_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.isect_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("GetTileBinEdges::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("GetTileBinEdges::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("GetTileBinEdges::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("get_tile_bin_edges.wgsl"),
                file_path: "get_tile_bin_edges.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("get_tile_bin_edges.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod rasterize {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub img_size: [u32; 2],
        pub _pad_img_size: [u8; 0x10 - core::mem::size_of::<[u32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub background: glam::Vec3A,
    }
    impl Uniforms {
        pub const fn new(img_size: [u32; 2], background: glam::Vec3A) -> Self {
            Self {
                img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub img_size: [u32; 2],
        pub background: glam::Vec3A,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                img_size: self.img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background: self.background,
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
            pub gaussian_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub colors: wgpu::BufferBinding<'a>,
            pub opacities: wgpu::BufferBinding<'a>,
            pub out_img: wgpu::BufferBinding<'a>,
            pub final_index: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.uniforms),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.opacities),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.out_img),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.final_index),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("Rasterize::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("Rasterize::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [26, 26, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Rasterize::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("rasterize.wgsl"),
                file_path: "rasterize.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rasterize.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod rasterize_backwards {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 8, offset: 0x0, type: `vec2<u32>`
        pub img_size: [u32; 2],
        pub _pad_img_size: [u8; 0x10 - core::mem::size_of::<[u32; 2]>()],
        /// size: 12, offset: 0x10, type: `vec3<f32>`
        pub background: glam::Vec3A,
    }
    impl Uniforms {
        pub const fn new(img_size: [u32; 2], background: glam::Vec3A) -> Self {
            Self {
                img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct UniformsInit {
        pub img_size: [u32; 2],
        pub background: glam::Vec3A,
    }
    impl UniformsInit {
        pub const fn build(&self) -> Uniforms {
            Uniforms {
                img_size: self.img_size,
                _pad_img_size: [0; 0x10 - core::mem::size_of::<[u32; 2]>()],
                background: self.background,
            }
        }
    }
    impl From<UniformsInit> for Uniforms {
        fn from(data: UniformsInit) -> Self {
            data.build()
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
            pub gaussian_ids_sorted: wgpu::BufferBinding<'a>,
            pub tile_bins: wgpu::BufferBinding<'a>,
            pub xys: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub colors: wgpu::BufferBinding<'a>,
            pub opacities: wgpu::BufferBinding<'a>,
            pub final_index: wgpu::BufferBinding<'a>,
            pub output: wgpu::BufferBinding<'a>,
            pub v_output: wgpu::BufferBinding<'a>,
            pub v_xy: wgpu::BufferBinding<'a>,
            pub v_conic: wgpu::BufferBinding<'a>,
            pub v_colors: wgpu::BufferBinding<'a>,
            pub v_opacity: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 14] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.uniforms),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.gaussian_ids_sorted),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.tile_bins),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.xys),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.opacities),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.final_index),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.output),
                    },
                    wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(self.v_output),
                    },
                    wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(self.v_xy),
                    },
                    wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(self.v_conic),
                    },
                    wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(self.v_colors),
                    },
                    wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(self.v_opacity),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("RasterizeBackwards::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 9,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 10,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 11,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 12,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 13,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("RasterizeBackwards::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [26, 26, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("RasterizeBackwards::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("rasterize_backwards.wgsl"),
                file_path: "rasterize_backwards.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rasterize_backwards.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod project_backwards {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Uniforms {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub viewmat: glam::Mat4,
        /// size: 8, offset: 0x40, type: `vec2<f32>`
        pub focal: [f32; 2],
        /// size: 8, offset: 0x48, type: `vec2<u32>`
        pub img_size: [u32; 2],
    }
    impl Uniforms {
        pub const fn new(
            viewmat: glam::Mat4,
            focal: [f32; 2],
            img_size: [u32; 2],
        ) -> Self {
            Self { viewmat, focal, img_size }
        }
    }
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub uniforms: wgpu::BufferBinding<'a>,
            pub means: wgpu::BufferBinding<'a>,
            pub scales: wgpu::BufferBinding<'a>,
            pub quats: wgpu::BufferBinding<'a>,
            pub radii: wgpu::BufferBinding<'a>,
            pub cov2ds: wgpu::BufferBinding<'a>,
            pub v_xy: wgpu::BufferBinding<'a>,
            pub v_conic: wgpu::BufferBinding<'a>,
            pub v_opacity: wgpu::BufferBinding<'a>,
            pub v_means: wgpu::BufferBinding<'a>,
            pub v_scales: wgpu::BufferBinding<'a>,
            pub v_quats: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.uniforms),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.quats),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.radii),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.cov2ds),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(self.v_xy),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(self.v_conic),
                    },
                    wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(self.v_opacity),
                    },
                    wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(self.v_means),
                    },
                    wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(self.v_scales),
                    },
                    wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(self.v_quats),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("ProjectBackwards::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 9,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 10,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 11,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("ProjectBackwards::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("ProjectBackwards::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("helpers.wgsl"),
                file_path: "helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("project_backwards.wgsl"),
                file_path: "project_backwards.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("project_backwards.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod prefix_sum_helpers {
    use super::{_root, _root::*};
    pub const THREADS_PER_GROUP: u32 = 512u32;
}
pub mod prefix_sum_scan {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub input: wgpu::BufferBinding<'a>,
            pub output: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.input),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.output),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("PrefixSumScan::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("PrefixSumScan::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [512, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("PrefixSumScan::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("scan\\prefix_sum_helpers.wgsl"),
                file_path: "scan\\prefix_sum_helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("prefix_sum_helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("scan\\prefix_sum_scan.wgsl"),
                file_path: "scan\\prefix_sum_scan.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("prefix_sum_scan.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod prefix_sum_scan_sums {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub input: wgpu::BufferBinding<'a>,
            pub output: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.input),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.output),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("PrefixSumScanSums::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("PrefixSumScanSums::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [512, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("PrefixSumScanSums::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("scan\\prefix_sum_helpers.wgsl"),
                file_path: "scan\\prefix_sum_helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("prefix_sum_helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("scan\\prefix_sum_scan_sums.wgsl"),
                file_path: "scan\\prefix_sum_scan_sums.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("prefix_sum_scan_sums.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod prefix_sum_add_scanned_sums {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub input: wgpu::BufferBinding<'a>,
            pub output: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.input),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.output),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("PrefixSumAddScannedSums::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("PrefixSumAddScannedSums::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [512, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("PrefixSumAddScannedSums::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("scan\\prefix_sum_helpers.wgsl"),
                file_path: "scan\\prefix_sum_helpers.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("prefix_sum_helpers".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("scan\\prefix_sum_add_scanned_sums.wgsl"),
                file_path: "scan\\prefix_sum_add_scanned_sums.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("prefix_sum_add_scanned_sums.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod sorting {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Config {
        /// size: 4, offset: 0x0, type: `u32`
        pub num_keys: u32,
        /// size: 4, offset: 0x4, type: `u32`
        pub num_blocks_per_wg: u32,
        /// size: 4, offset: 0x8, type: `u32`
        pub num_wgs: u32,
        /// size: 4, offset: 0xC, type: `u32`
        pub num_wgs_with_additional_blocks: u32,
        /// size: 4, offset: 0x10, type: `u32`
        pub num_reduce_wg_per_bin: u32,
        /// size: 4, offset: 0x14, type: `u32`
        pub num_scan_values: u32,
        /// size: 4, offset: 0x18, type: `u32`
        pub shift: u32,
    }
    impl Config {
        pub const fn new(
            num_keys: u32,
            num_blocks_per_wg: u32,
            num_wgs: u32,
            num_wgs_with_additional_blocks: u32,
            num_reduce_wg_per_bin: u32,
            num_scan_values: u32,
            shift: u32,
        ) -> Self {
            Self {
                num_keys,
                num_blocks_per_wg,
                num_wgs,
                num_wgs_with_additional_blocks,
                num_reduce_wg_per_bin,
                num_scan_values,
                shift,
            }
        }
    }
    pub const WG: u32 = 256u32;
    pub const BIN_COUNT: u32 = 16u32;
    pub const ELEMENTS_PER_THREAD: u32 = 4u32;
    pub const BLOCK_SIZE: u32 = 1024u32;
    pub const BITS_PER_PASS: u32 = 4u32;
}
pub mod sort_count {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub config: wgpu::BufferBinding<'a>,
            pub src: wgpu::BufferBinding<'a>,
            pub counts: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.config),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.src),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.counts),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("SortCount::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("SortCount::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("SortCount::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("sort\\sorting.wgsl"),
                file_path: "sort\\sorting.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("sorting".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("sort\\sort_count.wgsl"),
                file_path: "sort\\sort_count.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("sort_count.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod sort_reduce {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub config: wgpu::BufferBinding<'a>,
            pub counts: wgpu::BufferBinding<'a>,
            pub reduced: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.config),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.counts),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.reduced),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("SortReduce::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("SortReduce::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("SortReduce::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("sort\\sorting.wgsl"),
                file_path: "sort\\sorting.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("sorting".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("sort\\sort_reduce.wgsl"),
                file_path: "sort\\sort_reduce.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("sort_reduce.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod sort_scan_add {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub config: wgpu::BufferBinding<'a>,
            pub reduced: wgpu::BufferBinding<'a>,
            pub counts: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.config),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.reduced),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.counts),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("SortScanAdd::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("SortScanAdd::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("SortScanAdd::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("sort\\sorting.wgsl"),
                file_path: "sort\\sorting.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("sorting".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("sort\\sort_scan_add.wgsl"),
                file_path: "sort\\sort_scan_add.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("sort_scan_add.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod sort_scan {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub config: wgpu::BufferBinding<'a>,
            pub reduced: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.config),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.reduced),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("SortScan::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("SortScan::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("SortScan::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("sort\\sorting.wgsl"),
                file_path: "sort\\sorting.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("sorting".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("sort\\sort_scan.wgsl"),
                file_path: "sort\\sort_scan.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("sort_scan.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
pub mod sort_scatter {
    use super::{_root, _root::*};
    pub mod bind_groups {
        #[derive(Debug)]
        pub struct WgpuBindGroupLayout0<'a> {
            pub config: wgpu::BufferBinding<'a>,
            pub src: wgpu::BufferBinding<'a>,
            pub values: wgpu::BufferBinding<'a>,
            pub counts: wgpu::BufferBinding<'a>,
            pub out: wgpu::BufferBinding<'a>,
            pub out_values: wgpu::BufferBinding<'a>,
        }
        impl<'a> WgpuBindGroupLayout0<'a> {
            pub fn entries(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(self.config),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(self.src),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(self.values),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(self.counts),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(self.out),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(self.out_values),
                    },
                ]
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
                label: Some("SortScatter::BindGroup0::LayoutDescriptor"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: true,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage {
                                read_only: false,
                            },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
            pub fn get_bind_group_layout(
                device: &wgpu::Device,
            ) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(
                device: &wgpu::Device,
                bindings: WgpuBindGroupLayout0,
            ) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(&device);
                let entries = bindings.entries();
                let bind_group = device
                    .create_bind_group(
                        &wgpu::BindGroupDescriptor {
                            label: Some("SortScatter::BindGroup0"),
                            layout: &bind_group_layout,
                            entries: &entries,
                        },
                    );
                Self(bind_group)
            }
            pub fn set<'a>(&'a self, render_pass: &mut wgpu::ComputePass<'a>) {
                render_pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut wgpu::ComputePass<'a>) {
                self.bind_group0.set(pass);
            }
        }
    }
    pub fn set_bind_groups<'a>(
        pass: &mut wgpu::ComputePass<'a>,
        bind_group0: &'a bind_groups::WgpuBindGroup0,
    ) {
        bind_group0.set(pass);
    }
    pub mod compute {
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embedded(
            device: &wgpu::Device,
            shader_defs: std::collections::HashMap<
                String,
                naga_oil::compose::ShaderDefValue,
            >,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embedded(device, shader_defs);
            let layout = super::create_pipeline_layout(device);
            device
                .create_compute_pipeline(
                    &wgpu::ComputePipelineDescriptor {
                        label: Some("Compute Pipeline main"),
                        layout: Some(&layout),
                        module: &module,
                        entry_point: "main",
                    },
                )
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("SortScatter::PipelineLayout"),
                    bind_group_layouts: &[
                        &bind_groups::WgpuBindGroup0::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn load_shader_modules_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: &std::collections::HashMap<
            String,
            naga_oil::compose::ShaderDefValue,
        >,
    ) -> () {
        composer
            .add_composable_module(naga_oil::compose::ComposableModuleDescriptor {
                source: include_str!("sort\\sorting.wgsl"),
                file_path: "sort\\sorting.wgsl",
                language: naga_oil::compose::ShaderLanguage::Wgsl,
                shader_defs: shader_defs.clone(),
                as_name: Some("sorting".into()),
                ..Default::default()
            })
            .expect("failed to add composer module");
        ()
    }
    pub fn load_naga_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::naga::Module {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("sort\\sort_scatter.wgsl"),
                file_path: "sort\\sort_scatter.wgsl",
                shader_defs,
                ..Default::default()
            })
            .expect("failed to build naga module")
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> wgpu::ShaderModule {
        let mut composer = naga_oil::compose::Composer::default();
        load_shader_modules_embedded(&mut composer, &shader_defs);
        let module = load_naga_module_embedded(&mut composer, shader_defs);
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("sort_scatter.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
}
