mod codewriter;

use std::{borrow::Cow, io, sync::OnceLock};

use anyhow::Result;
use naga::{proc::GlobalCtx, Handle};
use naga_oil::compose::{
    ComposableModuleDescriptor, Composer, ComposerError, NagaModuleDescriptor,
};
use regex::Regex;
use thiserror::Error;

const DECORATION_PRE: &str = "X_naga_oil_mod_X";
const DECORATION_POST: &str = "X";

/// Converts
///   * "\"../types\"::RtsStruct" => "types::RtsStruct"
///   * "../more-shader-files/reachme" => "reachme"
pub fn make_valid_rust_import(value: &str) -> String {
    let v = value.replace("\"../", "").replace('"', "");
    std::path::Path::new(&v)
        .file_stem()
        .and_then(|name| name.to_str())
        .unwrap_or(&v)
        .to_string()
}

// https://github.com/bevyengine/naga_oil/blob/master/src/compose/mod.rs#L417-L419
fn decode(from: &str) -> String {
    String::from_utf8(data_encoding::BASE32_NOPAD.decode(from.as_bytes()).unwrap()).unwrap()
}

// https://github.com/bevyengine/naga_oil/blob/master/src/compose/mod.rs#L355-L363
fn undecorate_regex() -> &'static Regex {
    static MEM: OnceLock<Regex> = OnceLock::new();

    MEM.get_or_init(|| {
        Regex::new(
            format!(
                r"(\x1B\[\d+\w)?([\w\d_]+){}([A-Z0-9]*){}",
                regex_syntax::escape(DECORATION_PRE),
                regex_syntax::escape(DECORATION_POST)
            )
            .as_str(),
        )
        .unwrap()
    })
}

// https://github.com/bevyengine/naga_oil/blob/master/src/compose/mod.rs#L421-L431
fn demangle_str(string: &str) -> Cow<str> {
    undecorate_regex().replace_all(string, |caps: &regex::Captures| {
        format!(
            "{}{}::{}",
            caps.get(1).map(|cc| cc.as_str()).unwrap_or(""),
            make_valid_rust_import(&decode(caps.get(3).unwrap().as_str())),
            caps.get(2).unwrap().as_str()
        )
    })
}

fn name_from_mangled(string: &str) -> String {
    let demangled = demangle_str(string);
    let mut parts = demangled.as_ref().split("::").collect::<Vec<&str>>();
    parts.pop().unwrap().to_owned()
}

fn rust_type_name(ty: Handle<naga::Type>, ctx: &GlobalCtx) -> String {
    let wgsl_name = ty.to_wgsl(ctx);

    match wgsl_name.as_str() {
        "i32" | "u32" | "f32" => wgsl_name,
        "vec2<f32>" => "[f32; 2]".to_owned(),
        "vec3<f32>" => "[f32; 4]".to_owned(),
        "vec4<f32>" => "[f32; 4]".to_owned(),
        "mat4x4<f32>" => "[[f32; 4]; 4]".to_owned(),
        "vec2<u32>" => "[u32; 2]".to_owned(),
        "vec3<u32>" => "[u32: 4]".to_owned(),
        "vec4<u32>" => "[u32; 4]".to_owned(),
        _ => panic!("{}", wgsl_name),
    }
}

fn alignment_of(ty: Handle<naga::Type>, ctx: &GlobalCtx) -> usize {
    let wgsl_name = ty.to_wgsl(ctx);

    match wgsl_name.as_str() {
        "i32" | "u32" | "f32" => 4,
        "vec2<f32>" | "vec2<u32>" => 8,
        "vec3<f32>" | "vec4<f32>" | "mat4x4<f32>" | "vec3<u32>" | "vec4<u32>" => 16,
        _ => panic!("{}", wgsl_name),
    }
}

#[derive(Debug, Error)]
pub enum GenError {
    #[error("Failed to generate shader module.\n{1}")]
    ImportError(#[source] ComposerError, String),
    #[error("Failed to read/write input files {0}")]
    IoError(#[from] io::Error),
}

pub fn build_modules(
    paths: &[&str],
    includes: &[&str],
    base_path: &str,
    output_path: &str,
) -> Result<(), GenError> {
    let mut code = codewriter::CodeWriter::new();
    code.add_lines(&[
        "// Autogenerated by brush-wgsl from source wgsl files. Do not edit.",
        "#![allow(dead_code, clippy::all)]",
    ]);

    let base_path = &(base_path.to_owned() + "/");

    code.add_lines(&[
        "fn create_composer() -> naga_oil::compose::Composer {",
        "let mut composer = naga_oil::compose::Composer::default();",
    ]);

    let mut composer = Composer::default();
    for include in includes {
        let helper_source = &std::fs::read_to_string(include).unwrap();
        let helper_name = make_valid_rust_import(include);
        composer
            .add_composable_module(ComposableModuleDescriptor {
                source: helper_source,
                file_path: &include.replace(base_path, ""),
                as_name: Some(helper_name.to_string()),
                ..Default::default()
            })
            .unwrap();

        println!("cargo::rerun-if-changed={}", include);

        let rel_path = include.replace(base_path, "");

        code.add_lines(&[
            "composer.add_composable_module(naga_oil::compose::ComposableModuleDescriptor {",
            &format!("source: include_str!(\"./{rel_path}\"),"),
            &format!("file_path: \"{rel_path}\","),
            &format!("as_name: Some(\"{helper_name}\".to_string()),"),
            "..Default::default()",
            "}).unwrap();",
        ]);
    }

    code.add_lines(&["composer", "}"]);

    for path in paths {
        println!("cargo::rerun-if-changed={}", path);

        let source = &std::fs::read_to_string(path)?;
        let module = match composer.make_naga_module(NagaModuleDescriptor {
            source,
            file_path: path,
            ..Default::default()
        }) {
            Ok(m) => m,
            Err(e) => {
                let str = e.emit_to_string(&composer);
                return Err(GenError::ImportError(e, str));
            }
        };

        // get file name as module name
        let entries = &module.entry_points;
        assert!(entries.len() == 1, "Must have 1 entry per file");

        let entry = &entries[0];
        let [wg_x, wg_y, wg_z] = entry.workgroup_size;

        let mod_name = make_valid_rust_import(path);
        code.add_line(&format!("pub(crate) mod {mod_name} {{"));
        code.add_line(&format!(
            "pub(crate) const WORKGROUP_SIZE: [u32; 3] = [{wg_x}, {wg_y}, {wg_z}];"
        ));

        let ctx = &module.to_ctx();

        for t in module.constants.iter() {
            let type_and_value = match module.global_expressions[t.1.init] {
                naga::Expression::Literal(literal) => match literal {
                    naga::Literal::F64(v) => Some(format!("f32 = {v}")),
                    naga::Literal::F32(v) => Some(format!("f32 = {v}")),
                    naga::Literal::U32(v) => Some(format!("u32 = {v}")),
                    naga::Literal::I32(v) => Some(format!("i32 = {v}")),
                    naga::Literal::Bool(v) => Some(format!("bool = {v}")),
                    naga::Literal::I64(v) => Some(format!("i64 = {v}")),
                    naga::Literal::U64(v) => Some(format!("u64 = {v}")),
                    naga::Literal::AbstractInt(v) => Some(format!("i64 = {v}")),
                    naga::Literal::AbstractFloat(v) => Some(format!("f64 = {v}")),
                },
                _ => continue,
            };

            if let Some(type_and_value) = type_and_value {
                if let Some(name) = t.1.name.as_ref() {
                    code.add_line(&format!(
                        "pub(crate) const {}: {type_and_value};",
                        name_from_mangled(name)
                    ));
                }
            }
        }

        for t in module.types.iter() {
            match &t.1.inner {
                naga::TypeInner::Struct { members, span: _ }
                    if t.1.name.as_ref().unwrap() == "Uniforms" =>
                {
                    if members.is_empty() {
                        continue;
                    }
                    let max_align = members
                        .iter()
                        .map(|x| alignment_of(x.ty, ctx))
                        .max()
                        .unwrap();

                    code.add_line(&format!("#[repr(C, align({max_align}))]"));
                    code.add_line("#[derive(bytemuck::NoUninit, Debug, PartialEq, Clone, Copy)]");
                    code.add_line("pub(crate) struct Uniforms {");
                    for member in members {
                        let rust_name = rust_type_name(member.ty, ctx);
                        code.add_line(&format!(
                            "pub(crate) {}: {},",
                            member.name.as_ref().unwrap(),
                            rust_name
                        ));
                    }
                    code.add_line("}");
                }
                _ => continue,
            }
        }

        let rel_path = path.replace(base_path, "");

        code.add_lines(&[
            "",
            "pub(crate) fn create_shader_source(",
            "   shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>",
            ") -> naga::Module {",
            "let mut composer = super::create_composer();",
            "composer.make_naga_module(naga_oil::compose::NagaModuleDescriptor {",
            &format!("source: include_str!(\"{rel_path}\"),"),
            &format!("file_path: \"{path}\","),
            "shader_defs,",
            "..Default::default()",
            "}).unwrap()",
            "}",
            "}",
        ]);
    }

    std::fs::write(output_path, code.string())?;
    Ok(())
}
